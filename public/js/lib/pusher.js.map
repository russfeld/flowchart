{"version":3,"sources":["pusher.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"pusher.js","sourcesContent":["/*!\n * Pusher JavaScript Library v3.0.0\n * http://pusher.com/\n *\n * Copyright 2014, Pusher\n * Released under the MIT licence.\n */\n\n// Uses Node, AMD or browser globals to create a module. This example creates\n// a global even when AMD is used. This is useful if you have some scripts\n// that are loaded by an AMD loader, but they still want access to globals.\n// If you do not need to export a global for the AMD case,\n// see returnExports.js.\n\n// If you want something that will work in other stricter CommonJS environments,\n// or if you need to create a circular dependency, see commonJsStrictGlobal.js\n\n// Defines a module \"Pusher\".\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], function () {\n      return (root.Pusher = factory());\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like enviroments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals\n    root.Pusher = factory();\n  }\n}(this, function () {\n\n;(function() {\n  function Pusher(app_key, options) {\n    checkAppKey(app_key);\n    options = options || {};\n\n    var self = this;\n\n    this.key = app_key;\n    this.config = Pusher.Util.extend(\n      Pusher.getGlobalConfig(),\n      options.cluster ? Pusher.getClusterConfig(options.cluster) : {},\n      options\n    );\n\n    this.channels = new Pusher.Channels();\n    this.global_emitter = new Pusher.EventsDispatcher();\n    this.sessionID = Math.floor(Math.random() * 1000000000);\n\n    this.timeline = new Pusher.Timeline(this.key, this.sessionID, {\n      cluster: this.config.cluster,\n      features: Pusher.Util.getClientFeatures(),\n      params: this.config.timelineParams || {},\n      limit: 50,\n      level: Pusher.Timeline.INFO,\n      version: Pusher.VERSION\n    });\n    if (!this.config.disableStats) {\n      this.timelineSender = new Pusher.TimelineSender(this.timeline, {\n        host: this.config.statsHost,\n        path: \"/timeline/v2/jsonp\"\n      });\n    }\n\n    var getStrategy = function(options) {\n      var config = Pusher.Util.extend({}, self.config, options);\n      return Pusher.StrategyBuilder.build(\n        Pusher.getDefaultStrategy(config), config\n      );\n    };\n\n    this.connection = new Pusher.ConnectionManager(\n      this.key,\n      Pusher.Util.extend(\n        { getStrategy: getStrategy,\n          timeline: this.timeline,\n          activityTimeout: this.config.activity_timeout,\n          pongTimeout: this.config.pong_timeout,\n          unavailableTimeout: this.config.unavailable_timeout\n        },\n        this.config,\n        { encrypted: this.isEncrypted() }\n      )\n    );\n\n    this.connection.bind('connected', function() {\n      self.subscribeAll();\n      if (self.timelineSender) {\n        self.timelineSender.send(self.connection.isEncrypted());\n      }\n    });\n    this.connection.bind('message', function(params) {\n      var internal = (params.event.indexOf('pusher_internal:') === 0);\n      if (params.channel) {\n        var channel = self.channel(params.channel);\n        if (channel) {\n          channel.handleEvent(params.event, params.data);\n        }\n      }\n      // Emit globally [deprecated]\n      if (!internal) {\n        self.global_emitter.emit(params.event, params.data);\n      }\n    });\n    this.connection.bind('disconnected', function() {\n      self.channels.disconnect();\n    });\n    this.connection.bind('error', function(err) {\n      Pusher.warn('Error', err);\n    });\n\n    Pusher.instances.push(this);\n    this.timeline.info({ instances: Pusher.instances.length });\n\n    if (Pusher.isReady) {\n      self.connect();\n    }\n  }\n  var prototype = Pusher.prototype;\n\n  Pusher.instances = [];\n  Pusher.isReady = false;\n\n  // To receive log output provide a Pusher.log function, for example\n  // Pusher.log = function(m){console.log(m)}\n  Pusher.debug = function() {\n    if (!Pusher.log) {\n      return;\n    }\n    Pusher.log(Pusher.Util.stringify.apply(this, arguments));\n  };\n\n  Pusher.warn = function() {\n    var message = Pusher.Util.stringify.apply(this, arguments);\n    if (window.console) {\n      if (window.console.warn) {\n        window.console.warn(message);\n      } else if (window.console.log) {\n        window.console.log(message);\n      }\n    }\n    if (Pusher.log) {\n      Pusher.log(message);\n    }\n  };\n\n  Pusher.ready = function() {\n    Pusher.isReady = true;\n    for (var i = 0, l = Pusher.instances.length; i < l; i++) {\n      Pusher.instances[i].connect();\n    }\n  };\n\n  prototype.channel = function(name) {\n    return this.channels.find(name);\n  };\n\n  prototype.allChannels = function() {\n    return this.channels.all();\n  };\n\n  prototype.connect = function() {\n    this.connection.connect();\n\n    if (this.timelineSender) {\n      if (!this.timelineSenderTimer) {\n        var encrypted = this.connection.isEncrypted();\n        var timelineSender = this.timelineSender;\n        this.timelineSenderTimer = new Pusher.PeriodicTimer(60000, function() {\n          timelineSender.send(encrypted);\n        });\n      }\n    }\n  };\n\n  prototype.disconnect = function() {\n    this.connection.disconnect();\n\n    if (this.timelineSenderTimer) {\n      this.timelineSenderTimer.ensureAborted();\n      this.timelineSenderTimer = null;\n    }\n  };\n\n  prototype.bind = function(event_name, callback) {\n    this.global_emitter.bind(event_name, callback);\n    return this;\n  };\n\n  prototype.bind_all = function(callback) {\n    this.global_emitter.bind_all(callback);\n    return this;\n  };\n\n  prototype.subscribeAll = function() {\n    var channelName;\n    for (channelName in this.channels.channels) {\n      if (this.channels.channels.hasOwnProperty(channelName)) {\n        this.subscribe(channelName);\n      }\n    }\n  };\n\n  prototype.subscribe = function(channel_name) {\n    var channel = this.channels.add(channel_name, this);\n    if (this.connection.state === 'connected') {\n      channel.subscribe();\n    }\n    return channel;\n  };\n\n  prototype.unsubscribe = function(channel_name) {\n    var channel = this.channels.remove(channel_name);\n    if (channel && this.connection.state === 'connected') {\n      channel.unsubscribe();\n    }\n  };\n\n  prototype.send_event = function(event_name, data, channel) {\n    return this.connection.send_event(event_name, data, channel);\n  };\n\n  prototype.isEncrypted = function() {\n    if (Pusher.Util.getDocument().location.protocol === \"https:\") {\n      return true;\n    } else {\n      return Boolean(this.config.encrypted);\n    }\n  };\n\n  function checkAppKey(key) {\n    if (key === null || key === undefined) {\n      Pusher.warn(\n        'Warning', 'You must pass your app key when you instantiate Pusher.'\n      );\n    }\n  }\n\n  Pusher.HTTP = {};\n\n  this.Pusher = Pusher;\n}).call(this);\n\n;(function() {\n  // We need to bind clear functions this way to avoid exceptions on IE8\n  function clearTimeout(timer) {\n    window.clearTimeout(timer);\n  }\n  function clearInterval(timer) {\n    window.clearInterval(timer);\n  }\n\n  function GenericTimer(set, clear, delay, callback) {\n    var self = this;\n\n    this.clear = clear;\n    this.timer = set(function() {\n      if (self.timer !== null) {\n        self.timer = callback(self.timer);\n      }\n    }, delay);\n  }\n  var prototype = GenericTimer.prototype;\n\n  /** Returns whether the timer is still running.\n   *\n   * @return {Boolean}\n   */\n  prototype.isRunning = function() {\n    return this.timer !== null;\n  };\n\n  /** Aborts a timer when it's running. */\n  prototype.ensureAborted = function() {\n    if (this.timer) {\n      // Clear function is already bound\n      this.clear(this.timer);\n      this.timer = null;\n    }\n  };\n\n  /** Cross-browser compatible one-off timer abstraction.\n   *\n   * @param {Number} delay\n   * @param {Function} callback\n   */\n  Pusher.Timer = function(delay, callback) {\n    return new GenericTimer(setTimeout, clearTimeout, delay, function(timer) {\n      callback();\n      return null;\n    });\n  };\n  /** Cross-browser compatible periodic timer abstraction.\n   *\n   * @param {Number} delay\n   * @param {Function} callback\n   */\n  Pusher.PeriodicTimer = function(delay, callback) {\n    return new GenericTimer(setInterval, clearInterval, delay, function(timer) {\n      callback();\n      return timer;\n    });\n  };\n}).call(this);\n\n;(function() {\n  Pusher.Util = {\n    now: function() {\n      if (Date.now) {\n        return Date.now();\n      } else {\n        return new Date().valueOf();\n      }\n    },\n\n    defer: function(callback) {\n      return new Pusher.Timer(0, callback);\n    },\n\n    /** Merges multiple objects into the target argument.\n     *\n     * For properties that are plain Objects, performs a deep-merge. For the\n     * rest it just copies the value of the property.\n     *\n     * To extend prototypes use it as following:\n     *   Pusher.Util.extend(Target.prototype, Base.prototype)\n     *\n     * You can also use it to merge objects without altering them:\n     *   Pusher.Util.extend({}, object1, object2)\n     *\n     * @param  {Object} target\n     * @return {Object} the target argument\n     */\n    extend: function(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var extensions = arguments[i];\n        for (var property in extensions) {\n          if (extensions[property] && extensions[property].constructor &&\n              extensions[property].constructor === Object) {\n            target[property] = Pusher.Util.extend(\n              target[property] || {}, extensions[property]\n            );\n          } else {\n            target[property] = extensions[property];\n          }\n        }\n      }\n      return target;\n    },\n\n    stringify: function() {\n      var m = [\"Pusher\"];\n      for (var i = 0; i < arguments.length; i++) {\n        if (typeof arguments[i] === \"string\") {\n          m.push(arguments[i]);\n        } else {\n          if (window.JSON === undefined) {\n            m.push(arguments[i].toString());\n          } else {\n            m.push(JSON.stringify(arguments[i]));\n          }\n        }\n      }\n      return m.join(\" : \");\n    },\n\n    arrayIndexOf: function(array, item) { // MSIE doesn't have array.indexOf\n      var nativeIndexOf = Array.prototype.indexOf;\n      if (array === null) {\n        return -1;\n      }\n      if (nativeIndexOf && array.indexOf === nativeIndexOf) {\n        return array.indexOf(item);\n      }\n      for (var i = 0, l = array.length; i < l; i++) {\n        if (array[i] === item) {\n          return i;\n        }\n      }\n      return -1;\n    },\n\n    /** Applies a function f to all properties of an object.\n     *\n     * Function f gets 3 arguments passed:\n     * - element from the object\n     * - key of the element\n     * - reference to the object\n     *\n     * @param {Object} object\n     * @param {Function} f\n     */\n    objectApply: function(object, f) {\n      for (var key in object) {\n        if (Object.prototype.hasOwnProperty.call(object, key)) {\n          f(object[key], key, object);\n        }\n      }\n    },\n\n    /** Return a list of object's own property keys\n     *\n     * @param {Object} object\n     * @returns {Array}\n     */\n    keys: function(object) {\n      var keys = [];\n      Pusher.Util.objectApply(object, function(_, key) {\n        keys.push(key);\n      });\n      return keys;\n    },\n\n    /** Return a list of object's own property values\n     *\n     * @param {Object} object\n     * @returns {Array}\n     */\n    values: function(object) {\n      var values = [];\n      Pusher.Util.objectApply(object, function(value) {\n        values.push(value);\n      });\n      return values;\n    },\n\n    /** Applies a function f to all elements of an array.\n     *\n     * Function f gets 3 arguments passed:\n     * - element from the array\n     * - index of the element\n     * - reference to the array\n     *\n     * @param {Array} array\n     * @param {Function} f\n     */\n    apply: function(array, f, context) {\n      for (var i = 0; i < array.length; i++) {\n        f.call(context || window, array[i], i, array);\n      }\n    },\n\n    /** Maps all elements of the array and returns the result.\n     *\n     * Function f gets 4 arguments passed:\n     * - element from the array\n     * - index of the element\n     * - reference to the source array\n     * - reference to the destination array\n     *\n     * @param {Array} array\n     * @param {Function} f\n     */\n    map: function(array, f) {\n      var result = [];\n      for (var i = 0; i < array.length; i++) {\n        result.push(f(array[i], i, array, result));\n      }\n      return result;\n    },\n\n    /** Maps all elements of the object and returns the result.\n     *\n     * Function f gets 4 arguments passed:\n     * - element from the object\n     * - key of the element\n     * - reference to the source object\n     * - reference to the destination object\n     *\n     * @param {Object} object\n     * @param {Function} f\n     */\n    mapObject: function(object, f) {\n      var result = {};\n      Pusher.Util.objectApply(object, function(value, key) {\n        result[key] = f(value);\n      });\n      return result;\n    },\n\n    /** Filters elements of the array using a test function.\n     *\n     * Function test gets 4 arguments passed:\n     * - element from the array\n     * - index of the element\n     * - reference to the source array\n     * - reference to the destination array\n     *\n     * @param {Array} array\n     * @param {Function} f\n     */\n    filter: function(array, test) {\n      test = test || function(value) { return !!value; };\n\n      var result = [];\n      for (var i = 0; i < array.length; i++) {\n        if (test(array[i], i, array, result)) {\n          result.push(array[i]);\n        }\n      }\n      return result;\n    },\n\n    /** Filters properties of the object using a test function.\n     *\n     * Function test gets 4 arguments passed:\n     * - element from the object\n     * - key of the element\n     * - reference to the source object\n     * - reference to the destination object\n     *\n     * @param {Object} object\n     * @param {Function} f\n     */\n    filterObject: function(object, test) {\n      var result = {};\n      Pusher.Util.objectApply(object, function(value, key) {\n        if ((test && test(value, key, object, result)) || Boolean(value)) {\n          result[key] = value;\n        }\n      });\n      return result;\n    },\n\n    /** Flattens an object into a two-dimensional array.\n     *\n     * @param  {Object} object\n     * @return {Array} resulting array of [key, value] pairs\n     */\n    flatten: function(object) {\n      var result = [];\n      Pusher.Util.objectApply(object, function(value, key) {\n        result.push([key, value]);\n      });\n      return result;\n    },\n\n    /** Checks whether any element of the array passes the test.\n     *\n     * Function test gets 3 arguments passed:\n     * - element from the array\n     * - index of the element\n     * - reference to the source array\n     *\n     * @param {Array} array\n     * @param {Function} f\n     */\n    any: function(array, test) {\n      for (var i = 0; i < array.length; i++) {\n        if (test(array[i], i, array)) {\n          return true;\n        }\n      }\n      return false;\n    },\n\n    /** Checks whether all elements of the array pass the test.\n     *\n     * Function test gets 3 arguments passed:\n     * - element from the array\n     * - index of the element\n     * - reference to the source array\n     *\n     * @param {Array} array\n     * @param {Function} f\n     */\n    all: function(array, test) {\n      for (var i = 0; i < array.length; i++) {\n        if (!test(array[i], i, array)) {\n          return false;\n        }\n      }\n      return true;\n    },\n\n    /** Builds a function that will proxy a method call to its first argument.\n     *\n     * Allows partial application of arguments, so additional arguments are\n     * prepended to the argument list.\n     *\n     * @param  {String} name method name\n     * @return {Function} proxy function\n     */\n    method: function(name) {\n      var boundArguments = Array.prototype.slice.call(arguments, 1);\n      return function(object) {\n        return object[name].apply(object, boundArguments.concat(arguments));\n      };\n    },\n\n    getWindow: function() {\n      return window;\n    },\n\n    getDocument: function() {\n      return document;\n    },\n\n    getLocalStorage: function() {\n      try {\n        return window.localStorage;\n      } catch (e) {\n        return undefined;\n      }\n    },\n\n    getClientFeatures: function() {\n      return Pusher.Util.keys(\n        Pusher.Util.filterObject(\n          { \"ws\": Pusher.WSTransport },\n          function (t) { return t.isSupported({}); }\n        )\n      );\n    },\n\n    addWindowListener: function(event, listener) {\n      var _window = Pusher.Util.getWindow();\n      if (_window.addEventListener !== undefined) {\n        _window.addEventListener(event, listener, false);\n      } else {\n        _window.attachEvent(\"on\" + event, listener);\n      }\n    },\n\n    removeWindowListener: function(event, listener) {\n      var _window = Pusher.Util.getWindow();\n      if (_window.addEventListener !== undefined) {\n        _window.removeEventListener(event, listener, false);\n      } else {\n        _window.detachEvent(\"on\" + event, listener);\n      }\n    },\n\n    isXHRSupported: function() {\n      var XHR = window.XMLHttpRequest;\n      return Boolean(XHR) && (new XHR()).withCredentials !== undefined;\n    },\n\n    isXDRSupported: function(encrypted) {\n      var protocol = encrypted ? \"https:\" : \"http:\";\n      var documentProtocol = Pusher.Util.getDocument().location.protocol;\n      return Boolean(window.XDomainRequest) && documentProtocol === protocol;\n    }\n  };\n}).call(this);\n\n;(function() {\n  Pusher.VERSION = '3.0.0';\n  Pusher.PROTOCOL = 7;\n\n  // DEPRECATED: WS connection parameters\n  Pusher.host = 'ws.pusherapp.com';\n  Pusher.ws_port = 80;\n  Pusher.wss_port = 443;\n  // DEPRECATED: SockJS fallback parameters\n  Pusher.sockjs_host = 'sockjs.pusher.com';\n  Pusher.sockjs_http_port = 80;\n  Pusher.sockjs_https_port = 443;\n  Pusher.sockjs_path = \"/pusher\";\n  // DEPRECATED: Stats\n  Pusher.stats_host = 'stats.pusher.com';\n  // DEPRECATED: Other settings\n  Pusher.channel_auth_endpoint = '/pusher/auth';\n  Pusher.channel_auth_transport = 'ajax';\n  Pusher.activity_timeout = 120000;\n  Pusher.pong_timeout = 30000;\n  Pusher.unavailable_timeout = 10000;\n  // CDN configuration\n  Pusher.cdn_http = 'http://js.pusher.com/';\n  Pusher.cdn_https = 'https://js.pusher.com/';\n  Pusher.dependency_suffix = '';\n\n  Pusher.getDefaultStrategy = function(config) {\n    var wsStrategy;\n    if (config.encrypted) {\n      wsStrategy = [\n        \":best_connected_ever\",\n        \":ws_loop\",\n        [\":delayed\", 2000, [\":http_fallback_loop\"]]\n      ];\n    } else {\n      wsStrategy = [\n        \":best_connected_ever\",\n        \":ws_loop\",\n        [\":delayed\", 2000, [\":wss_loop\"]],\n        [\":delayed\", 5000, [\":http_fallback_loop\"]]\n      ];\n    }\n\n    return [\n      [\":def\", \"ws_options\", {\n        hostUnencrypted: config.wsHost + \":\" + config.wsPort,\n        hostEncrypted: config.wsHost + \":\" + config.wssPort\n      }],\n      [\":def\", \"wss_options\", [\":extend\", \":ws_options\", {\n        encrypted: true\n      }]],\n      [\":def\", \"sockjs_options\", {\n        hostUnencrypted: config.httpHost + \":\" + config.httpPort,\n        hostEncrypted: config.httpHost + \":\" + config.httpsPort,\n        httpPath: config.httpPath\n      }],\n      [\":def\", \"timeouts\", {\n        loop: true,\n        timeout: 15000,\n        timeoutLimit: 60000\n      }],\n\n      [\":def\", \"ws_manager\", [\":transport_manager\", {\n        lives: 2,\n        minPingDelay: 10000,\n        maxPingDelay: config.activity_timeout\n      }]],\n      [\":def\", \"streaming_manager\", [\":transport_manager\", {\n        lives: 2,\n        minPingDelay: 10000,\n        maxPingDelay: config.activity_timeout\n      }]],\n\n      [\":def_transport\", \"ws\", \"ws\", 3, \":ws_options\", \":ws_manager\"],\n      [\":def_transport\", \"wss\", \"ws\", 3, \":wss_options\", \":ws_manager\"],\n      [\":def_transport\", \"sockjs\", \"sockjs\", 1, \":sockjs_options\"],\n      [\":def_transport\", \"xhr_streaming\", \"xhr_streaming\", 1, \":sockjs_options\", \":streaming_manager\"],\n      [\":def_transport\", \"xdr_streaming\", \"xdr_streaming\", 1, \":sockjs_options\", \":streaming_manager\"],\n      [\":def_transport\", \"xhr_polling\", \"xhr_polling\", 1, \":sockjs_options\"],\n      [\":def_transport\", \"xdr_polling\", \"xdr_polling\", 1, \":sockjs_options\"],\n\n      [\":def\", \"ws_loop\", [\":sequential\", \":timeouts\", \":ws\"]],\n      [\":def\", \"wss_loop\", [\":sequential\", \":timeouts\", \":wss\"]],\n      [\":def\", \"sockjs_loop\", [\":sequential\", \":timeouts\", \":sockjs\"]],\n\n      [\":def\", \"streaming_loop\", [\":sequential\", \":timeouts\",\n        [\":if\", [\":is_supported\", \":xhr_streaming\"],\n          \":xhr_streaming\",\n          \":xdr_streaming\"\n        ]\n      ]],\n      [\":def\", \"polling_loop\", [\":sequential\", \":timeouts\",\n        [\":if\", [\":is_supported\", \":xhr_polling\"],\n          \":xhr_polling\",\n          \":xdr_polling\"\n        ]\n      ]],\n\n      [\":def\", \"http_loop\", [\":if\", [\":is_supported\", \":streaming_loop\"], [\n        \":best_connected_ever\",\n          \":streaming_loop\",\n          [\":delayed\", 4000, [\":polling_loop\"]]\n      ], [\n        \":polling_loop\"\n      ]]],\n\n      [\":def\", \"http_fallback_loop\",\n        [\":if\", [\":is_supported\", \":http_loop\"], [\n          \":http_loop\"\n        ], [\n          \":sockjs_loop\"\n        ]]\n      ],\n\n      [\":def\", \"strategy\",\n        [\":cached\", 1800000,\n          [\":first_connected\",\n            [\":if\", [\":is_supported\", \":ws\"],\n              wsStrategy,\n              \":http_fallback_loop\"\n            ]\n          ]\n        ]\n      ]\n    ];\n  };\n}).call(this);\n\n;(function() {\n  Pusher.getGlobalConfig = function() {\n    return {\n      wsHost: Pusher.host,\n      wsPort: Pusher.ws_port,\n      wssPort: Pusher.wss_port,\n      httpHost: Pusher.sockjs_host,\n      httpPort: Pusher.sockjs_http_port,\n      httpsPort: Pusher.sockjs_https_port,\n      httpPath: Pusher.sockjs_path,\n      statsHost: Pusher.stats_host,\n      authEndpoint: Pusher.channel_auth_endpoint,\n      authTransport: Pusher.channel_auth_transport,\n      // TODO make this consistent with other options in next major version\n      activity_timeout: Pusher.activity_timeout,\n      pong_timeout: Pusher.pong_timeout,\n      unavailable_timeout: Pusher.unavailable_timeout\n    };\n  };\n\n  Pusher.getClusterConfig = function(clusterName) {\n    return {\n      wsHost: \"ws-\" + clusterName + \".pusher.com\",\n      httpHost: \"sockjs-\" + clusterName + \".pusher.com\"\n    };\n  };\n}).call(this);\n\n;(function() {\n  function buildExceptionClass(name) {\n    var constructor = function(message) {\n      Error.call(this, message);\n      this.name = name;\n    };\n    Pusher.Util.extend(constructor.prototype, Error.prototype);\n\n    return constructor;\n  }\n\n  /** Error classes used throughout pusher-js library. */\n  Pusher.Errors = {\n    BadEventName: buildExceptionClass(\"BadEventName\"),\n    RequestTimedOut: buildExceptionClass(\"RequestTimedOut\"),\n    TransportPriorityTooLow: buildExceptionClass(\"TransportPriorityTooLow\"),\n    TransportClosed: buildExceptionClass(\"TransportClosed\"),\n    UnsupportedTransport: buildExceptionClass(\"UnsupportedTransport\"),\n    UnsupportedStrategy: buildExceptionClass(\"UnsupportedStrategy\")\n  };\n}).call(this);\n\n;(function() {\n  /** Manages callback bindings and event emitting.\n   *\n   * @param Function failThrough called when no listeners are bound to an event\n   */\n  function EventsDispatcher(failThrough) {\n    this.callbacks = new CallbackRegistry();\n    this.global_callbacks = [];\n    this.failThrough = failThrough;\n  }\n  var prototype = EventsDispatcher.prototype;\n\n  prototype.bind = function(eventName, callback, context) {\n    this.callbacks.add(eventName, callback, context);\n    return this;\n  };\n\n  prototype.bind_all = function(callback) {\n    this.global_callbacks.push(callback);\n    return this;\n  };\n\n  prototype.unbind = function(eventName, callback, context) {\n    this.callbacks.remove(eventName, callback, context);\n    return this;\n  };\n\n  prototype.unbind_all = function(eventName, callback) {\n    this.callbacks.remove(eventName, callback);\n    return this;\n  };\n\n  prototype.emit = function(eventName, data) {\n    var i;\n\n    for (i = 0; i < this.global_callbacks.length; i++) {\n      this.global_callbacks[i](eventName, data);\n    }\n\n    var callbacks = this.callbacks.get(eventName);\n    if (callbacks && callbacks.length > 0) {\n      for (i = 0; i < callbacks.length; i++) {\n        callbacks[i].fn.call(callbacks[i].context || window, data);\n      }\n    } else if (this.failThrough) {\n      this.failThrough(eventName, data);\n    }\n\n    return this;\n  };\n\n  /** Callback registry helper. */\n\n  function CallbackRegistry() {\n    this._callbacks = {};\n  }\n\n  CallbackRegistry.prototype.get = function(name) {\n    return this._callbacks[prefix(name)];\n  };\n\n  CallbackRegistry.prototype.add = function(name, callback, context) {\n    var prefixedEventName = prefix(name);\n    this._callbacks[prefixedEventName] = this._callbacks[prefixedEventName] || [];\n    this._callbacks[prefixedEventName].push({\n      fn: callback,\n      context: context\n    });\n  };\n\n  CallbackRegistry.prototype.remove = function(name, callback, context) {\n    if (!name && !callback && !context) {\n      this._callbacks = {};\n      return;\n    }\n\n    var names = name ? [prefix(name)] : Pusher.Util.keys(this._callbacks);\n\n    if (callback || context) {\n      Pusher.Util.apply(names, function(name) {\n        this._callbacks[name] = Pusher.Util.filter(\n          this._callbacks[name] || [],\n          function(binding) {\n            return (callback && callback !== binding.fn) ||\n                   (context && context !== binding.context);\n          }\n        );\n        if (this._callbacks[name].length === 0) {\n          delete this._callbacks[name];\n        }\n      }, this);\n    } else {\n      Pusher.Util.apply(names, function(name) {\n        delete this._callbacks[name];\n      }, this);\n    }\n  };\n\n  function prefix(name) {\n    return \"_\" + name;\n  }\n\n  Pusher.EventsDispatcher = EventsDispatcher;\n}).call(this);\n\n(function() {\n  /** Builds receivers for JSONP and Script requests.\n   *\n   * Each receiver is an object with following fields:\n   * - number - unique (for the factory instance), numerical id of the receiver\n   * - id - a string ID that can be used in DOM attributes\n   * - name - name of the function triggering the receiver\n   * - callback - callback function\n   *\n   * Receivers are triggered only once, on the first callback call.\n   *\n   * Receivers can be called by their name or by accessing factory object\n   * by the number key.\n   *\n   * @param {String} prefix the prefix used in ids\n   * @param {String} name the name of the object\n   */\n  function ScriptReceiverFactory(prefix, name) {\n    this.lastId = 0;\n    this.prefix = prefix;\n    this.name = name;\n  }\n  var prototype = ScriptReceiverFactory.prototype;\n\n  /** Creates a script receiver.\n   *\n   * @param {Function} callback\n   * @return {ScriptReceiver}\n   */\n  prototype.create = function(callback) {\n    this.lastId++;\n\n    var number = this.lastId;\n    var id = this.prefix + number;\n    var name = this.name + \"[\" + number + \"]\";\n\n    var called = false;\n    var callbackWrapper = function() {\n      if (!called) {\n        callback.apply(null, arguments);\n        called = true;\n      }\n    };\n\n    this[number] = callbackWrapper;\n    return { number: number, id: id, name: name, callback: callbackWrapper };\n  };\n\n  /** Removes the script receiver from the list.\n   *\n   * @param {ScriptReceiver} receiver\n   */\n  prototype.remove = function(receiver) {\n    delete this[receiver.number];\n  };\n\n  Pusher.ScriptReceiverFactory = ScriptReceiverFactory;\n  Pusher.ScriptReceivers = new ScriptReceiverFactory(\n    \"_pusher_script_\", \"Pusher.ScriptReceivers\"\n  );\n}).call(this);\n\n(function() {\n  /** Sends a generic HTTP GET request using a script tag.\n   *\n   * By constructing URL in a specific way, it can be used for loading\n   * JavaScript resources or JSONP requests. It can notify about errors, but\n   * only in certain environments. Please take care of monitoring the state of\n   * the request yourself.\n   *\n   * @param {String} src\n   */\n  function ScriptRequest(src) {\n    this.src = src;\n  }\n  var prototype = ScriptRequest.prototype;\n\n  /** Sends the actual script request.\n   *\n   * @param {ScriptReceiver} receiver\n   */\n  prototype.send = function(receiver) {\n    var self = this;\n    var errorString = \"Error loading \" + self.src;\n\n    self.script = document.createElement(\"script\");\n    self.script.id = receiver.id;\n    self.script.src = self.src;\n    self.script.type = \"text/javascript\";\n    self.script.charset = \"UTF-8\";\n\n    if (self.script.addEventListener) {\n      self.script.onerror = function() {\n        receiver.callback(errorString);\n      };\n      self.script.onload = function() {\n        receiver.callback(null);\n      };\n    } else {\n      self.script.onreadystatechange = function() {\n        if (self.script.readyState === 'loaded' ||\n            self.script.readyState === 'complete') {\n          receiver.callback(null);\n        }\n      };\n    }\n\n    // Opera<11.6 hack for missing onerror callback\n    if (self.script.async === undefined && document.attachEvent &&\n        /opera/i.test(navigator.userAgent)) {\n      self.errorScript = document.createElement(\"script\");\n      self.errorScript.id = receiver.id + \"_error\";\n      self.errorScript.text = receiver.name + \"('\" + errorString + \"');\";\n      self.script.async = self.errorScript.async = false;\n    } else {\n      self.script.async = true;\n    }\n\n    var head = document.getElementsByTagName('head')[0];\n    head.insertBefore(self.script, head.firstChild);\n    if (self.errorScript) {\n      head.insertBefore(self.errorScript, self.script.nextSibling);\n    }\n  };\n\n  /** Cleans up the DOM remains of the script request. */\n  prototype.cleanup = function() {\n    if (this.script) {\n      this.script.onload = this.script.onerror = null;\n      this.script.onreadystatechange = null;\n    }\n    if (this.script && this.script.parentNode) {\n      this.script.parentNode.removeChild(this.script);\n    }\n    if (this.errorScript && this.errorScript.parentNode) {\n      this.errorScript.parentNode.removeChild(this.errorScript);\n    }\n    this.script = null;\n    this.errorScript = null;\n  };\n\n  Pusher.ScriptRequest = ScriptRequest;\n}).call(this);\n\n;(function() {\n  /** Handles loading dependency files.\n   *\n   * Dependency loaders don't remember whether a resource has been loaded or\n   * not. It is caller's responsibility to make sure the resource is not loaded\n   * twice. This is because it's impossible to detect resource loading status\n   * without knowing its content.\n   *\n   * Options:\n   * - cdn_http - url to HTTP CND\n   * - cdn_https - url to HTTPS CDN\n   * - version - version of pusher-js\n   * - suffix - suffix appended to all names of dependency files\n   *\n   * @param {Object} options\n   */\n  function DependencyLoader(options) {\n    this.options = options;\n    this.receivers = options.receivers || Pusher.ScriptReceivers;\n    this.loading = {};\n  }\n  var prototype = DependencyLoader.prototype;\n\n  /** Loads the dependency from CDN.\n   *\n   * @param  {String} name\n   * @param  {Function} callback\n   */\n  prototype.load = function(name, options, callback) {\n    var self = this;\n\n    if (self.loading[name] && self.loading[name].length > 0) {\n      self.loading[name].push(callback);\n    } else {\n      self.loading[name] = [callback];\n\n      var request = new Pusher.ScriptRequest(self.getPath(name, options));\n      var receiver = self.receivers.create(function(error) {\n        self.receivers.remove(receiver);\n\n        if (self.loading[name]) {\n          var callbacks = self.loading[name];\n          delete self.loading[name];\n\n          var successCallback = function(wasSuccessful) {\n            if (!wasSuccessful) {\n              request.cleanup();\n            }\n          };\n          for (var i = 0; i < callbacks.length; i++) {\n            callbacks[i](error, successCallback);\n          }\n        }\n      });\n      request.send(receiver);\n    }\n  };\n\n  /** Returns a root URL for pusher-js CDN.\n   *\n   * @returns {String}\n   */\n  prototype.getRoot = function(options) {\n    var cdn;\n    var protocol = Pusher.Util.getDocument().location.protocol;\n    if ((options && options.encrypted) || protocol === \"https:\") {\n      cdn = this.options.cdn_https;\n    } else {\n      cdn = this.options.cdn_http;\n    }\n    // make sure there are no double slashes\n    return cdn.replace(/\\/*$/, \"\") + \"/\" + this.options.version;\n  };\n\n  /** Returns a full path to a dependency file.\n   *\n   * @param {String} name\n   * @returns {String}\n   */\n  prototype.getPath = function(name, options) {\n    return this.getRoot(options) + '/' + name + this.options.suffix + '.js';\n  };\n\n  Pusher.DependencyLoader = DependencyLoader;\n}).call(this);\n\n;(function() {\n  Pusher.DependenciesReceivers = new Pusher.ScriptReceiverFactory(\n    \"_pusher_dependencies\", \"Pusher.DependenciesReceivers\"\n  );\n  Pusher.Dependencies = new Pusher.DependencyLoader({\n    cdn_http: Pusher.cdn_http,\n    cdn_https: Pusher.cdn_https,\n    version: Pusher.VERSION,\n    suffix: Pusher.dependency_suffix,\n    receivers: Pusher.DependenciesReceivers\n  });\n\n  function initialize() {\n    Pusher.ready();\n  }\n\n  // Allows calling a function when the document body is available\n   function onDocumentBody(callback) {\n    if (document.body) {\n      callback();\n    } else {\n      setTimeout(function() {\n        onDocumentBody(callback);\n      }, 0);\n    }\n  }\n\n  function initializeOnDocumentBody() {\n    onDocumentBody(initialize);\n  }\n\n  if (!window.JSON) {\n    Pusher.Dependencies.load(\"json2\", {}, initializeOnDocumentBody);\n  } else {\n    initializeOnDocumentBody();\n  }\n})();\n\n(function() {\n\n  var Base64 = {\n    encode: function (s) {\n      return btoa(utob(s));\n    }\n  };\n\n  var fromCharCode = String.fromCharCode;\n\n  var b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  var b64tab = {};\n\n  for (var i = 0, l = b64chars.length; i < l; i++) {\n    b64tab[b64chars.charAt(i)] = i;\n  }\n\n  var cb_utob = function(c) {\n    var cc = c.charCodeAt(0);\n    return cc < 0x80 ? c\n        : cc < 0x800 ? fromCharCode(0xc0 | (cc >>> 6)) +\n                       fromCharCode(0x80 | (cc & 0x3f))\n        : fromCharCode(0xe0 | ((cc >>> 12) & 0x0f)) +\n          fromCharCode(0x80 | ((cc >>>  6) & 0x3f)) +\n          fromCharCode(0x80 | ( cc         & 0x3f));\n  };\n\n  var utob = function(u) {\n    return u.replace(/[^\\x00-\\x7F]/g, cb_utob);\n  };\n\n  var cb_encode = function(ccc) {\n    var padlen = [0, 2, 1][ccc.length % 3];\n    var ord = ccc.charCodeAt(0) << 16\n      | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)\n      | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0));\n    var chars = [\n      b64chars.charAt( ord >>> 18),\n      b64chars.charAt((ord >>> 12) & 63),\n      padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),\n      padlen >= 1 ? '=' : b64chars.charAt(ord & 63)\n    ];\n    return chars.join('');\n  };\n\n  var btoa = window.btoa || function(b) {\n    return b.replace(/[\\s\\S]{1,3}/g, cb_encode);\n  };\n\n  Pusher.Base64 = Base64;\n\n}).call(this);\n\n(function() {\n  /** Sends data via JSONP.\n   *\n   * Data is a key-value map. Its values are JSON-encoded and then passed\n   * through base64. Finally, keys and encoded values are appended to the query\n   * string.\n   *\n   * The class itself does not guarantee raising errors on failures, as it's not\n   * possible to support such feature on all browsers. Instead, JSONP endpoint\n   * should call back in a way that's easy to distinguish from browser calls,\n   * for example by passing a second argument to the receiver.\n   *\n   * @param {String} url\n   * @param {Object} data key-value map of data to be submitted\n   */\n  function JSONPRequest(url, data) {\n    this.url = url;\n    this.data = data;\n  }\n  var prototype = JSONPRequest.prototype;\n\n  /** Sends the actual JSONP request.\n   *\n   * @param {ScriptReceiver} receiver\n   */\n  prototype.send = function(receiver) {\n    if (this.request) {\n      return;\n    }\n\n    var params = Pusher.Util.filterObject(this.data, function(value) {\n      return value !== undefined;\n    });\n    var query = Pusher.Util.map(\n      Pusher.Util.flatten(encodeParamsObject(params)),\n      Pusher.Util.method(\"join\", \"=\")\n    ).join(\"&\");\n    var url = this.url + \"/\" + receiver.number + \"?\" + query;\n\n    this.request = new Pusher.ScriptRequest(url);\n    this.request.send(receiver);\n  };\n\n  /** Cleans up the DOM remains of the JSONP request. */\n  prototype.cleanup = function() {\n    if (this.request) {\n      this.request.cleanup();\n    }\n  };\n\n  function encodeParamsObject(data) {\n    return Pusher.Util.mapObject(data, function(value) {\n      if (typeof value === \"object\") {\n        value = JSON.stringify(value);\n      }\n      return encodeURIComponent(Pusher.Base64.encode(value.toString()));\n    });\n  }\n\n  Pusher.JSONPRequest = JSONPRequest;\n}).call(this);\n\n(function() {\n  function Timeline(key, session, options) {\n    this.key = key;\n    this.session = session;\n    this.events = [];\n    this.options = options || {};\n    this.sent = 0;\n    this.uniqueID = 0;\n  }\n  var prototype = Timeline.prototype;\n\n  // Log levels\n  Timeline.ERROR = 3;\n  Timeline.INFO = 6;\n  Timeline.DEBUG = 7;\n\n  prototype.log = function(level, event) {\n    if (level <= this.options.level) {\n      this.events.push(\n        Pusher.Util.extend({}, event, { timestamp: Pusher.Util.now() })\n      );\n      if (this.options.limit && this.events.length > this.options.limit) {\n        this.events.shift();\n      }\n    }\n  };\n\n  prototype.error = function(event) {\n    this.log(Timeline.ERROR, event);\n  };\n\n  prototype.info = function(event) {\n    this.log(Timeline.INFO, event);\n  };\n\n  prototype.debug = function(event) {\n    this.log(Timeline.DEBUG, event);\n  };\n\n  prototype.isEmpty = function() {\n    return this.events.length === 0;\n  };\n\n  prototype.send = function(sendJSONP, callback) {\n    var self = this;\n\n    var data = Pusher.Util.extend({\n      session: self.session,\n      bundle: self.sent + 1,\n      key: self.key,\n      lib: \"js\",\n      version: self.options.version,\n      cluster: self.options.cluster,\n      features: self.options.features,\n      timeline: self.events\n    }, self.options.params);\n\n    self.events = [];\n    sendJSONP(data, function(error, result) {\n      if (!error) {\n        self.sent++;\n      }\n      if (callback) {\n        callback(error, result);\n      }\n    });\n\n    return true;\n  };\n\n  prototype.generateUniqueID = function() {\n    this.uniqueID++;\n    return this.uniqueID;\n  };\n\n  Pusher.Timeline = Timeline;\n}).call(this);\n\n(function() {\n  function TimelineSender(timeline, options) {\n    this.timeline = timeline;\n    this.options = options || {};\n  }\n  var prototype = TimelineSender.prototype;\n\n  prototype.send = function(encrypted, callback) {\n    var self = this;\n\n    if (self.timeline.isEmpty()) {\n      return;\n    }\n\n    var sendJSONP = function(data, callback) {\n      var scheme = \"http\" + (encrypted ? \"s\" : \"\") + \"://\";\n      var url = scheme + (self.host || self.options.host) + self.options.path;\n      var request = new Pusher.JSONPRequest(url, data);\n\n      var receiver = Pusher.ScriptReceivers.create(function(error, result) {\n        Pusher.ScriptReceivers.remove(receiver);\n        request.cleanup();\n\n        if (result && result.host) {\n          self.host = result.host;\n        }\n        if (callback) {\n          callback(error, result);\n        }\n      });\n      request.send(receiver);\n    };\n    self.timeline.send(sendJSONP, callback);\n  };\n\n  Pusher.TimelineSender = TimelineSender;\n}).call(this);\n\n;(function() {\n  /** Launches all substrategies and emits prioritized connected transports.\n   *\n   * @param {Array} strategies\n   */\n  function BestConnectedEverStrategy(strategies) {\n    this.strategies = strategies;\n  }\n  var prototype = BestConnectedEverStrategy.prototype;\n\n  prototype.isSupported = function() {\n    return Pusher.Util.any(this.strategies, Pusher.Util.method(\"isSupported\"));\n  };\n\n  prototype.connect = function(minPriority, callback) {\n    return connect(this.strategies, minPriority, function(i, runners) {\n      return function(error, handshake) {\n        runners[i].error = error;\n        if (error) {\n          if (allRunnersFailed(runners)) {\n            callback(true);\n          }\n          return;\n        }\n        Pusher.Util.apply(runners, function(runner) {\n          runner.forceMinPriority(handshake.transport.priority);\n        });\n        callback(null, handshake);\n      };\n    });\n  };\n\n  /** Connects to all strategies in parallel.\n   *\n   * Callback builder should be a function that takes two arguments: index\n   * and a list of runners. It should return another function that will be\n   * passed to the substrategy with given index. Runners can be aborted using\n   * abortRunner(s) functions from this class.\n   *\n   * @param  {Array} strategies\n   * @param  {Function} callbackBuilder\n   * @return {Object} strategy runner\n   */\n  function connect(strategies, minPriority, callbackBuilder) {\n    var runners = Pusher.Util.map(strategies, function(strategy, i, _, rs) {\n      return strategy.connect(minPriority, callbackBuilder(i, rs));\n    });\n    return {\n      abort: function() {\n        Pusher.Util.apply(runners, abortRunner);\n      },\n      forceMinPriority: function(p) {\n        Pusher.Util.apply(runners, function(runner) {\n          runner.forceMinPriority(p);\n        });\n      }\n    };\n  }\n\n  function allRunnersFailed(runners) {\n    return Pusher.Util.all(runners, function(runner) {\n      return Boolean(runner.error);\n    });\n  }\n\n  function abortRunner(runner) {\n    if (!runner.error && !runner.aborted) {\n      runner.abort();\n      runner.aborted = true;\n    }\n  }\n\n  Pusher.BestConnectedEverStrategy = BestConnectedEverStrategy;\n}).call(this);\n\n;(function() {\n  /** Caches last successful transport and uses it for following attempts.\n   *\n   * @param {Strategy} strategy\n   * @param {Object} transports\n   * @param {Object} options\n   */\n  function CachedStrategy(strategy, transports, options) {\n    this.strategy = strategy;\n    this.transports = transports;\n    this.ttl = options.ttl || 1800*1000;\n    this.encrypted = options.encrypted;\n    this.timeline = options.timeline;\n  }\n  var prototype = CachedStrategy.prototype;\n\n  prototype.isSupported = function() {\n    return this.strategy.isSupported();\n  };\n\n  prototype.connect = function(minPriority, callback) {\n    var encrypted = this.encrypted;\n    var info = fetchTransportCache(encrypted);\n\n    var strategies = [this.strategy];\n    if (info && info.timestamp + this.ttl >= Pusher.Util.now()) {\n      var transport = this.transports[info.transport];\n      if (transport) {\n        this.timeline.info({\n          cached: true,\n          transport: info.transport,\n          latency: info.latency\n        });\n        strategies.push(new Pusher.SequentialStrategy([transport], {\n          timeout: info.latency * 2 + 1000,\n          failFast: true\n        }));\n      }\n    }\n\n    var startTimestamp = Pusher.Util.now();\n    var runner = strategies.pop().connect(\n      minPriority,\n      function cb(error, handshake) {\n        if (error) {\n          flushTransportCache(encrypted);\n          if (strategies.length > 0) {\n            startTimestamp = Pusher.Util.now();\n            runner = strategies.pop().connect(minPriority, cb);\n          } else {\n            callback(error);\n          }\n        } else {\n          storeTransportCache(\n            encrypted,\n            handshake.transport.name,\n            Pusher.Util.now() - startTimestamp\n          );\n          callback(null, handshake);\n        }\n      }\n    );\n\n    return {\n      abort: function() {\n        runner.abort();\n      },\n      forceMinPriority: function(p) {\n        minPriority = p;\n        if (runner) {\n          runner.forceMinPriority(p);\n        }\n      }\n    };\n  };\n\n  function getTransportCacheKey(encrypted) {\n    return \"pusherTransport\" + (encrypted ? \"Encrypted\" : \"Unencrypted\");\n  }\n\n  function fetchTransportCache(encrypted) {\n    var storage = Pusher.Util.getLocalStorage();\n    if (storage) {\n      try {\n        var serializedCache = storage[getTransportCacheKey(encrypted)];\n        if (serializedCache) {\n          return JSON.parse(serializedCache);\n        }\n      } catch (e) {\n        flushTransportCache(encrypted);\n      }\n    }\n    return null;\n  }\n\n  function storeTransportCache(encrypted, transport, latency) {\n    var storage = Pusher.Util.getLocalStorage();\n    if (storage) {\n      try {\n        storage[getTransportCacheKey(encrypted)] = JSON.stringify({\n          timestamp: Pusher.Util.now(),\n          transport: transport,\n          latency: latency\n        });\n      } catch (e) {\n        // catch over quota exceptions raised by localStorage\n      }\n    }\n  }\n\n  function flushTransportCache(encrypted) {\n    var storage = Pusher.Util.getLocalStorage();\n    if (storage) {\n      try {\n        delete storage[getTransportCacheKey(encrypted)];\n      } catch (e) {\n        // catch exceptions raised by localStorage\n      }\n    }\n  }\n\n  Pusher.CachedStrategy = CachedStrategy;\n}).call(this);\n\n;(function() {\n  /** Runs substrategy after specified delay.\n   *\n   * Options:\n   * - delay - time in miliseconds to delay the substrategy attempt\n   *\n   * @param {Strategy} strategy\n   * @param {Object} options\n   */\n  function DelayedStrategy(strategy, options) {\n    this.strategy = strategy;\n    this.options = { delay: options.delay };\n  }\n  var prototype = DelayedStrategy.prototype;\n\n  prototype.isSupported = function() {\n    return this.strategy.isSupported();\n  };\n\n  prototype.connect = function(minPriority, callback) {\n    var strategy = this.strategy;\n    var runner;\n    var timer = new Pusher.Timer(this.options.delay, function() {\n      runner = strategy.connect(minPriority, callback);\n    });\n\n    return {\n      abort: function() {\n        timer.ensureAborted();\n        if (runner) {\n          runner.abort();\n        }\n      },\n      forceMinPriority: function(p) {\n        minPriority = p;\n        if (runner) {\n          runner.forceMinPriority(p);\n        }\n      }\n    };\n  };\n\n  Pusher.DelayedStrategy = DelayedStrategy;\n}).call(this);\n\n;(function() {\n  /** Launches the substrategy and terminates on the first open connection.\n   *\n   * @param {Strategy} strategy\n   */\n  function FirstConnectedStrategy(strategy) {\n    this.strategy = strategy;\n  }\n  var prototype = FirstConnectedStrategy.prototype;\n\n  prototype.isSupported = function() {\n    return this.strategy.isSupported();\n  };\n\n  prototype.connect = function(minPriority, callback) {\n    var runner = this.strategy.connect(\n      minPriority,\n      function(error, handshake) {\n        if (handshake) {\n          runner.abort();\n        }\n        callback(error, handshake);\n      }\n    );\n    return runner;\n  };\n\n  Pusher.FirstConnectedStrategy = FirstConnectedStrategy;\n}).call(this);\n\n;(function() {\n  /** Proxies method calls to one of substrategies basing on the test function.\n   *\n   * @param {Function} test\n   * @param {Strategy} trueBranch strategy used when test returns true\n   * @param {Strategy} falseBranch strategy used when test returns false\n   */\n  function IfStrategy(test, trueBranch, falseBranch) {\n    this.test = test;\n    this.trueBranch = trueBranch;\n    this.falseBranch = falseBranch;\n  }\n  var prototype = IfStrategy.prototype;\n\n  prototype.isSupported = function() {\n    var branch = this.test() ? this.trueBranch : this.falseBranch;\n    return branch.isSupported();\n  };\n\n  prototype.connect = function(minPriority, callback) {\n    var branch = this.test() ? this.trueBranch : this.falseBranch;\n    return branch.connect(minPriority, callback);\n  };\n\n  Pusher.IfStrategy = IfStrategy;\n}).call(this);\n\n;(function() {\n  /** Loops through strategies with optional timeouts.\n   *\n   * Options:\n   * - loop - whether it should loop through the substrategy list\n   * - timeout - initial timeout for a single substrategy\n   * - timeoutLimit - maximum timeout\n   *\n   * @param {Strategy[]} strategies\n   * @param {Object} options\n   */\n  function SequentialStrategy(strategies, options) {\n    this.strategies = strategies;\n    this.loop = Boolean(options.loop);\n    this.failFast = Boolean(options.failFast);\n    this.timeout = options.timeout;\n    this.timeoutLimit = options.timeoutLimit;\n  }\n  var prototype = SequentialStrategy.prototype;\n\n  prototype.isSupported = function() {\n    return Pusher.Util.any(this.strategies, Pusher.Util.method(\"isSupported\"));\n  };\n\n  prototype.connect = function(minPriority, callback) {\n    var self = this;\n\n    var strategies = this.strategies;\n    var current = 0;\n    var timeout = this.timeout;\n    var runner = null;\n\n    var tryNextStrategy = function(error, handshake) {\n      if (handshake) {\n        callback(null, handshake);\n      } else {\n        current = current + 1;\n        if (self.loop) {\n          current = current % strategies.length;\n        }\n\n        if (current < strategies.length) {\n          if (timeout) {\n            timeout = timeout * 2;\n            if (self.timeoutLimit) {\n              timeout = Math.min(timeout, self.timeoutLimit);\n            }\n          }\n          runner = self.tryStrategy(\n            strategies[current],\n            minPriority,\n            { timeout: timeout, failFast: self.failFast },\n            tryNextStrategy\n          );\n        } else {\n          callback(true);\n        }\n      }\n    };\n\n    runner = this.tryStrategy(\n      strategies[current],\n      minPriority,\n      { timeout: timeout, failFast: this.failFast },\n      tryNextStrategy\n    );\n\n    return {\n      abort: function() {\n        runner.abort();\n      },\n      forceMinPriority: function(p) {\n        minPriority = p;\n        if (runner) {\n          runner.forceMinPriority(p);\n        }\n      }\n    };\n  };\n\n  /** @private */\n  prototype.tryStrategy = function(strategy, minPriority, options, callback) {\n    var timer = null;\n    var runner = null;\n\n    if (options.timeout > 0) {\n      timer = new Pusher.Timer(options.timeout, function() {\n        runner.abort();\n        callback(true);\n      });\n    }\n\n    runner = strategy.connect(minPriority, function(error, handshake) {\n      if (error && timer && timer.isRunning() && !options.failFast) {\n        // advance to the next strategy after the timeout\n        return;\n      }\n      if (timer) {\n        timer.ensureAborted();\n      }\n      callback(error, handshake);\n    });\n\n    return {\n      abort: function() {\n        if (timer) {\n          timer.ensureAborted();\n        }\n        runner.abort();\n      },\n      forceMinPriority: function(p) {\n        runner.forceMinPriority(p);\n      }\n    };\n  };\n\n  Pusher.SequentialStrategy = SequentialStrategy;\n}).call(this);\n\n;(function() {\n  /** Provides a strategy interface for transports.\n   *\n   * @param {String} name\n   * @param {Number} priority\n   * @param {Class} transport\n   * @param {Object} options\n   */\n  function TransportStrategy(name, priority, transport, options) {\n    this.name = name;\n    this.priority = priority;\n    this.transport = transport;\n    this.options = options || {};\n  }\n  var prototype = TransportStrategy.prototype;\n\n  /** Returns whether the transport is supported in the browser.\n   *\n   * @returns {Boolean}\n   */\n  prototype.isSupported = function() {\n    return this.transport.isSupported({\n      encrypted: this.options.encrypted\n    });\n  };\n\n  /** Launches a connection attempt and returns a strategy runner.\n   *\n   * @param  {Function} callback\n   * @return {Object} strategy runner\n   */\n  prototype.connect = function(minPriority, callback) {\n    if (!this.isSupported()) {\n      return failAttempt(new Pusher.Errors.UnsupportedStrategy(), callback);\n    } else if (this.priority < minPriority) {\n      return failAttempt(new Pusher.Errors.TransportPriorityTooLow(), callback);\n    }\n\n    var self = this;\n    var connected = false;\n\n    var transport = this.transport.createConnection(\n      this.name, this.priority, this.options.key, this.options\n    );\n    var handshake = null;\n\n    var onInitialized = function() {\n      transport.unbind(\"initialized\", onInitialized);\n      transport.connect();\n    };\n    var onOpen = function() {\n      handshake = new Pusher.Handshake(transport, function(result) {\n        connected = true;\n        unbindListeners();\n        callback(null, result);\n      });\n    };\n    var onError = function(error) {\n      unbindListeners();\n      callback(error);\n    };\n    var onClosed = function() {\n      unbindListeners();\n      callback(new Pusher.Errors.TransportClosed(transport));\n    };\n\n    var unbindListeners = function() {\n      transport.unbind(\"initialized\", onInitialized);\n      transport.unbind(\"open\", onOpen);\n      transport.unbind(\"error\", onError);\n      transport.unbind(\"closed\", onClosed);\n    };\n\n    transport.bind(\"initialized\", onInitialized);\n    transport.bind(\"open\", onOpen);\n    transport.bind(\"error\", onError);\n    transport.bind(\"closed\", onClosed);\n\n    // connect will be called automatically after initialization\n    transport.initialize();\n\n    return {\n      abort: function() {\n        if (connected) {\n          return;\n        }\n        unbindListeners();\n        if (handshake) {\n          handshake.close();\n        } else {\n          transport.close();\n        }\n      },\n      forceMinPriority: function(p) {\n        if (connected) {\n          return;\n        }\n        if (self.priority < p) {\n          if (handshake) {\n            handshake.close();\n          } else {\n            transport.close();\n          }\n        }\n      }\n    };\n  };\n\n  function failAttempt(error, callback) {\n    Pusher.Util.defer(function() {\n      callback(error);\n    });\n    return {\n      abort: function() {},\n      forceMinPriority: function() {}\n    };\n  }\n\n  Pusher.TransportStrategy = TransportStrategy;\n}).call(this);\n\n(function() {\n  function getGenericURL(baseScheme, params, path) {\n    var scheme = baseScheme + (params.encrypted ? \"s\" : \"\");\n    var host = params.encrypted ? params.hostEncrypted : params.hostUnencrypted;\n    return scheme + \"://\" + host + path;\n  }\n\n  function getGenericPath(key, queryString) {\n    var path = \"/app/\" + key;\n    var query =\n      \"?protocol=\" + Pusher.PROTOCOL +\n      \"&client=js\" +\n      \"&version=\" + Pusher.VERSION +\n      (queryString ? (\"&\" + queryString) : \"\");\n    return path + query;\n  }\n\n  /** URL schemes for different transport types. */\n  Pusher.URLSchemes = {\n    /** Standard WebSocket URL scheme. */\n    ws: {\n      getInitial: function(key, params) {\n        return getGenericURL(\"ws\", params, getGenericPath(key, \"flash=false\"));\n      }\n    },\n    /** SockJS URL scheme. Supplies the path separately from the initial URL. */\n    sockjs: {\n      getInitial: function(key, params) {\n        return getGenericURL(\"http\", params, params.httpPath || \"/pusher\", \"\");\n      },\n      getPath: function(key, params) {\n        return getGenericPath(key);\n      }\n    },\n    /** URL scheme for HTTP transports. Basically, WS scheme with a prefix. */\n    http: {\n      getInitial: function(key, params) {\n        var path = (params.httpPath || \"/pusher\") + getGenericPath(key);\n        return getGenericURL(\"http\", params, path);\n      }\n    }\n  };\n}).call(this);\n\n(function() {\n  /** Provides universal API for transport connections.\n   *\n   * Transport connection is a low-level object that wraps a connection method\n   * and exposes a simple evented interface for the connection state and\n   * messaging. It does not implement Pusher-specific WebSocket protocol.\n   *\n   * Additionally, it fetches resources needed for transport to work and exposes\n   * an interface for querying transport features.\n   *\n   * States:\n   * - new - initial state after constructing the object\n   * - initializing - during initialization phase, usually fetching resources\n   * - intialized - ready to establish a connection\n   * - connection - when connection is being established\n   * - open - when connection ready to be used\n   * - closed - after connection was closed be either side\n   *\n   * Emits:\n   * - error - after the connection raised an error\n   *\n   * Options:\n   * - encrypted - whether connection should use ssl\n   * - hostEncrypted - host to connect to when connection is encrypted\n   * - hostUnencrypted - host to connect to when connection is not encrypted\n   *\n   * @param {String} key application key\n   * @param {Object} options\n   */\n  function TransportConnection(hooks, name, priority, key, options) {\n    Pusher.EventsDispatcher.call(this);\n\n    this.hooks = hooks;\n    this.name = name;\n    this.priority = priority;\n    this.key = key;\n    this.options = options;\n\n    this.state = \"new\";\n    this.timeline = options.timeline;\n    this.activityTimeout = options.activityTimeout;\n    this.id = this.timeline.generateUniqueID();\n  }\n  var prototype = TransportConnection.prototype;\n  Pusher.Util.extend(prototype, Pusher.EventsDispatcher.prototype);\n\n  /** Checks whether the transport handles activity checks by itself.\n   *\n   * @return {Boolean}\n   */\n  prototype.handlesActivityChecks = function() {\n    return Boolean(this.hooks.handlesActivityChecks);\n  };\n\n  /** Checks whether the transport supports the ping/pong API.\n   *\n   * @return {Boolean}\n   */\n  prototype.supportsPing = function() {\n    return Boolean(this.hooks.supportsPing);\n  };\n\n  /** Initializes the transport.\n   *\n   * Fetches resources if needed and then transitions to initialized.\n   */\n  prototype.initialize = function() {\n    var self = this;\n\n    self.timeline.info(self.buildTimelineMessage({\n      transport: self.name + (self.options.encrypted ? \"s\" : \"\")\n    }));\n\n    if (self.hooks.isInitialized()) {\n      self.changeState(\"initialized\");\n    } else if (self.hooks.file) {\n      self.changeState(\"initializing\");\n      Pusher.Dependencies.load(\n        self.hooks.file,\n        { encrypted: self.options.encrypted },\n        function(error, callback) {\n          if (self.hooks.isInitialized()) {\n            self.changeState(\"initialized\");\n            callback(true);\n          } else {\n            if (error) {\n              self.onError(error);\n            }\n            self.onClose();\n            callback(false);\n          }\n        }\n      );\n    } else {\n      self.onClose();\n    }\n  };\n\n  /** Tries to establish a connection.\n   *\n   * @returns {Boolean} false if transport is in invalid state\n   */\n  prototype.connect = function() {\n    var self = this;\n\n    if (self.socket || self.state !== \"initialized\") {\n      return false;\n    }\n\n    var url = self.hooks.urls.getInitial(self.key, self.options);\n    try {\n      self.socket = self.hooks.getSocket(url, self.options);\n    } catch (e) {\n      Pusher.Util.defer(function() {\n        self.onError(e);\n        self.changeState(\"closed\");\n      });\n      return false;\n    }\n\n    self.bindListeners();\n\n    Pusher.debug(\"Connecting\", { transport: self.name, url: url });\n    self.changeState(\"connecting\");\n    return true;\n  };\n\n  /** Closes the connection.\n   *\n   * @return {Boolean} true if there was a connection to close\n   */\n  prototype.close = function() {\n    if (this.socket) {\n      this.socket.close();\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  /** Sends data over the open connection.\n   *\n   * @param {String} data\n   * @return {Boolean} true only when in the \"open\" state\n   */\n  prototype.send = function(data) {\n    var self = this;\n\n    if (self.state === \"open\") {\n      // Workaround for MobileSafari bug (see https://gist.github.com/2052006)\n      Pusher.Util.defer(function() {\n        if (self.socket) {\n          self.socket.send(data);\n        }\n      });\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  /** Sends a ping if the connection is open and transport supports it. */\n  prototype.ping = function() {\n    if (this.state === \"open\" && this.supportsPing()) {\n      this.socket.ping();\n    }\n  };\n\n  /** @private */\n  prototype.onOpen = function() {\n    if (this.hooks.beforeOpen) {\n      this.hooks.beforeOpen(\n        this.socket, this.hooks.urls.getPath(this.key, this.options)\n      );\n    }\n    this.changeState(\"open\");\n    this.socket.onopen = undefined;\n  };\n\n  /** @private */\n  prototype.onError = function(error) {\n    this.emit(\"error\", { type: 'WebSocketError', error: error });\n    this.timeline.error(this.buildTimelineMessage({ error: error.toString() }));\n  };\n\n  /** @private */\n  prototype.onClose = function(closeEvent) {\n    if (closeEvent) {\n      this.changeState(\"closed\", {\n        code: closeEvent.code,\n        reason: closeEvent.reason,\n        wasClean: closeEvent.wasClean\n      });\n    } else {\n      this.changeState(\"closed\");\n    }\n    this.unbindListeners();\n    this.socket = undefined;\n  };\n\n  /** @private */\n  prototype.onMessage = function(message) {\n    this.emit(\"message\", message);\n  };\n\n  /** @private */\n  prototype.onActivity = function() {\n    this.emit(\"activity\");\n  };\n\n  /** @private */\n  prototype.bindListeners = function() {\n    var self = this;\n\n    self.socket.onopen = function() {\n      self.onOpen();\n    };\n    self.socket.onerror = function(error) {\n      self.onError(error);\n    };\n    self.socket.onclose = function(closeEvent) {\n      self.onClose(closeEvent);\n    };\n    self.socket.onmessage = function(message) {\n      self.onMessage(message);\n    };\n\n    if (self.supportsPing()) {\n      self.socket.onactivity = function() { self.onActivity(); };\n    }\n  };\n\n  /** @private */\n  prototype.unbindListeners = function() {\n    if (this.socket) {\n      this.socket.onopen = undefined;\n      this.socket.onerror = undefined;\n      this.socket.onclose = undefined;\n      this.socket.onmessage = undefined;\n      if (this.supportsPing()) {\n        this.socket.onactivity = undefined;\n      }\n    }\n  };\n\n  /** @private */\n  prototype.changeState = function(state, params) {\n    this.state = state;\n    this.timeline.info(this.buildTimelineMessage({\n      state: state,\n      params: params\n    }));\n    this.emit(state, params);\n  };\n\n  /** @private */\n  prototype.buildTimelineMessage = function(message) {\n    return Pusher.Util.extend({ cid: this.id }, message);\n  };\n\n  Pusher.TransportConnection = TransportConnection;\n}).call(this);\n\n(function() {\n  /** Provides interface for transport connection instantiation.\n   *\n   * Takes transport-specific hooks as the only argument, which allow checking\n   * for transport support and creating its connections.\n   *\n   * Supported hooks:\n   * - file - the name of the file to be fetched during initialization\n   * - urls - URL scheme to be used by transport\n   * - handlesActivityCheck - true when the transport handles activity checks\n   * - supportsPing - true when the transport has a ping/activity API\n   * - isSupported - tells whether the transport is supported in the environment\n   * - getSocket - creates a WebSocket-compatible transport socket\n   *\n   * See transports.js for specific implementations.\n   *\n   * @param {Object} hooks object containing all needed transport hooks\n   */\n  function Transport(hooks) {\n    this.hooks = hooks;\n  }\n  var prototype = Transport.prototype;\n\n  /** Returns whether the transport is supported in the environment.\n   *\n   * @param {Object} environment the environment details (encryption, settings)\n   * @returns {Boolean} true when the transport is supported\n   */\n  prototype.isSupported = function(environment) {\n    return this.hooks.isSupported(environment);\n  };\n\n  /** Creates a transport connection.\n   *\n   * @param {String} name\n   * @param {Number} priority\n   * @param {String} key the application key\n   * @param {Object} options\n   * @returns {TransportConnection}\n   */\n  prototype.createConnection = function(name, priority, key, options) {\n    return new Pusher.TransportConnection(\n      this.hooks, name, priority, key, options\n    );\n  };\n\n  Pusher.Transport = Transport;\n}).call(this);\n\n(function() {\n  /** WebSocket transport.\n   *\n   * Uses native WebSocket implementation, including MozWebSocket supported by\n   * earlier Firefox versions.\n   */\n  Pusher.WSTransport = new Pusher.Transport({\n    urls: Pusher.URLSchemes.ws,\n    handlesActivityChecks: false,\n    supportsPing: false,\n\n    isInitialized: function() {\n      return Boolean(window.WebSocket || window.MozWebSocket);\n    },\n    isSupported: function() {\n      return Boolean(window.WebSocket || window.MozWebSocket);\n    },\n    getSocket: function(url) {\n      var Constructor = window.WebSocket || window.MozWebSocket;\n      return new Constructor(url);\n    }\n  });\n\n  /** SockJS transport. */\n  Pusher.SockJSTransport = new Pusher.Transport({\n    file: \"sockjs\",\n    urls: Pusher.URLSchemes.sockjs,\n    handlesActivityChecks: true,\n    supportsPing: false,\n\n    isSupported: function() {\n      return true;\n    },\n    isInitialized: function() {\n      return window.SockJS !== undefined;\n    },\n    getSocket: function(url, options) {\n      return new SockJS(url, null, {\n        js_path: Pusher.Dependencies.getPath(\"sockjs\", {\n          encrypted: options.encrypted\n        }),\n        ignore_null_origin: options.ignoreNullOrigin\n      });\n    },\n    beforeOpen: function(socket, path) {\n      socket.send(JSON.stringify({\n        path: path\n      }));\n    }\n  });\n\n  var httpConfiguration = {\n    urls: Pusher.URLSchemes.http,\n    handlesActivityChecks: false,\n    supportsPing: true,\n    isInitialized: function() {\n      return Boolean(Pusher.HTTP.Socket);\n    }\n  };\n\n  var streamingConfiguration = Pusher.Util.extend(\n    { getSocket: function(url) {\n        return Pusher.HTTP.getStreamingSocket(url);\n      }\n    },\n    httpConfiguration\n  );\n  var pollingConfiguration = Pusher.Util.extend(\n    { getSocket: function(url) {\n        return Pusher.HTTP.getPollingSocket(url);\n      }\n    },\n    httpConfiguration\n  );\n\n  var xhrConfiguration = {\n    file: \"xhr\",\n    isSupported: Pusher.Util.isXHRSupported\n  };\n  var xdrConfiguration = {\n    file: \"xdr\",\n    isSupported: function(environment) {\n      return Pusher.Util.isXDRSupported(environment.encrypted);\n    }\n  };\n\n  /** HTTP streaming transport using CORS-enabled XMLHttpRequest. */\n  Pusher.XHRStreamingTransport = new Pusher.Transport(\n    Pusher.Util.extend({}, streamingConfiguration, xhrConfiguration)\n  );\n  /** HTTP streaming transport using XDomainRequest (IE 8,9). */\n  Pusher.XDRStreamingTransport = new Pusher.Transport(\n    Pusher.Util.extend({}, streamingConfiguration, xdrConfiguration)\n  );\n  /** HTTP long-polling transport using CORS-enabled XMLHttpRequest. */\n  Pusher.XHRPollingTransport = new Pusher.Transport(\n    Pusher.Util.extend({}, pollingConfiguration, xhrConfiguration)\n  );\n  /** HTTP long-polling transport using XDomainRequest (IE 8,9). */\n  Pusher.XDRPollingTransport = new Pusher.Transport(\n    Pusher.Util.extend({}, pollingConfiguration, xdrConfiguration)\n  );\n}).call(this);\n\n;(function() {\n  /** Creates transport connections monitored by a transport manager.\n   *\n   * When a transport is closed, it might mean the environment does not support\n   * it. It's possible that messages get stuck in an intermediate buffer or\n   * proxies terminate inactive connections. To combat these problems,\n   * assistants monitor the connection lifetime, report unclean exits and\n   * adjust ping timeouts to keep the connection active. The decision to disable\n   * a transport is the manager's responsibility.\n   *\n   * @param {TransportManager} manager\n   * @param {TransportConnection} transport\n   * @param {Object} options\n   */\n  function AssistantToTheTransportManager(manager, transport, options) {\n    this.manager = manager;\n    this.transport = transport;\n    this.minPingDelay = options.minPingDelay;\n    this.maxPingDelay = options.maxPingDelay;\n    this.pingDelay = undefined;\n  }\n  var prototype = AssistantToTheTransportManager.prototype;\n\n  /** Creates a transport connection.\n   *\n   * This function has the same API as Transport#createConnection.\n   *\n   * @param {String} name\n   * @param {Number} priority\n   * @param {String} key the application key\n   * @param {Object} options\n   * @returns {TransportConnection}\n   */\n  prototype.createConnection = function(name, priority, key, options) {\n    var self = this;\n\n    options = Pusher.Util.extend({}, options, {\n      activityTimeout: self.pingDelay\n    });\n    var connection = self.transport.createConnection(\n      name, priority, key, options\n    );\n\n    var openTimestamp = null;\n\n    var onOpen = function() {\n      connection.unbind(\"open\", onOpen);\n      connection.bind(\"closed\", onClosed);\n      openTimestamp = Pusher.Util.now();\n    };\n    var onClosed = function(closeEvent) {\n      connection.unbind(\"closed\", onClosed);\n\n      if (closeEvent.code === 1002 || closeEvent.code === 1003) {\n        // we don't want to use transports not obeying the protocol\n        self.manager.reportDeath();\n      } else if (!closeEvent.wasClean && openTimestamp) {\n        // report deaths only for short-living transport\n        var lifespan = Pusher.Util.now() - openTimestamp;\n        if (lifespan < 2 * self.maxPingDelay) {\n          self.manager.reportDeath();\n          self.pingDelay = Math.max(lifespan / 2, self.minPingDelay);\n        }\n      }\n    };\n\n    connection.bind(\"open\", onOpen);\n    return connection;\n  };\n\n  /** Returns whether the transport is supported in the environment.\n   *\n   * This function has the same API as Transport#isSupported. Might return false\n   * when the manager decides to kill the transport.\n   *\n   * @param {Object} environment the environment details (encryption, settings)\n   * @returns {Boolean} true when the transport is supported\n   */\n  prototype.isSupported = function(environment) {\n    return this.manager.isAlive() && this.transport.isSupported(environment);\n  };\n\n  Pusher.AssistantToTheTransportManager = AssistantToTheTransportManager;\n}).call(this);\n\n;(function() {\n  /** Keeps track of the number of lives left for a transport.\n   *\n   * In the beginning of a session, transports may be assigned a number of\n   * lives. When an AssistantToTheTransportManager instance reports a transport\n   * connection closed uncleanly, the transport loses a life. When the number\n   * of lives drops to zero, the transport gets disabled by its manager.\n   *\n   * @param {Object} options\n   */\n  function TransportManager(options) {\n    this.options = options || {};\n    this.livesLeft = this.options.lives || Infinity;\n  }\n  var prototype = TransportManager.prototype;\n\n  /** Creates a assistant for the transport.\n   *\n   * @param {Transport} transport\n   * @returns {AssistantToTheTransportManager}\n   */\n  prototype.getAssistant = function(transport) {\n    return new Pusher.AssistantToTheTransportManager(this, transport, {\n      minPingDelay: this.options.minPingDelay,\n      maxPingDelay: this.options.maxPingDelay\n    });\n  };\n\n  /** Returns whether the transport has any lives left.\n   *\n   * @returns {Boolean}\n   */\n  prototype.isAlive = function() {\n    return this.livesLeft > 0;\n  };\n\n  /** Takes one life from the transport. */\n  prototype.reportDeath = function() {\n    this.livesLeft -= 1;\n  };\n\n  Pusher.TransportManager = TransportManager;\n}).call(this);\n\n;(function() {\n  var StrategyBuilder = {\n    /** Transforms a JSON scheme to a strategy tree.\n     *\n     * @param {Array} scheme JSON strategy scheme\n     * @param {Object} options a hash of symbols to be included in the scheme\n     * @returns {Strategy} strategy tree that's represented by the scheme\n     */\n    build: function(scheme, options) {\n      var context = Pusher.Util.extend({}, globalContext, options);\n      return evaluate(scheme, context)[1].strategy;\n    }\n  };\n\n  var transports = {\n    ws: Pusher.WSTransport,\n    sockjs: Pusher.SockJSTransport,\n    xhr_streaming: Pusher.XHRStreamingTransport,\n    xdr_streaming: Pusher.XDRStreamingTransport,\n    xhr_polling: Pusher.XHRPollingTransport,\n    xdr_polling: Pusher.XDRPollingTransport\n  };\n\n  var UnsupportedStrategy = {\n    isSupported: function() {\n      return false;\n    },\n    connect: function(_, callback) {\n      var deferred = Pusher.Util.defer(function() {\n        callback(new Pusher.Errors.UnsupportedStrategy());\n      });\n      return {\n        abort: function() {\n          deferred.ensureAborted();\n        },\n        forceMinPriority: function() {}\n      };\n    }\n  };\n\n  // DSL bindings\n\n  function returnWithOriginalContext(f) {\n    return function(context) {\n      return [f.apply(this, arguments), context];\n    };\n  }\n\n  var globalContext = {\n    extend: function(context, first, second) {\n      return [Pusher.Util.extend({}, first, second), context];\n    },\n\n    def: function(context, name, value) {\n      if (context[name] !== undefined) {\n        throw \"Redefining symbol \" + name;\n      }\n      context[name] = value;\n      return [undefined, context];\n    },\n\n    def_transport: function(context, name, type, priority, options, manager) {\n      var transportClass = transports[type];\n      if (!transportClass) {\n        throw new Pusher.Errors.UnsupportedTransport(type);\n      }\n\n      var enabled =\n        (!context.enabledTransports ||\n          Pusher.Util.arrayIndexOf(context.enabledTransports, name) !== -1) &&\n        (!context.disabledTransports ||\n          Pusher.Util.arrayIndexOf(context.disabledTransports, name) === -1);\n\n      var transport;\n      if (enabled) {\n        transport = new Pusher.TransportStrategy(\n          name,\n          priority,\n          manager ? manager.getAssistant(transportClass) : transportClass,\n          Pusher.Util.extend({\n            key: context.key,\n            encrypted: context.encrypted,\n            timeline: context.timeline,\n            ignoreNullOrigin: context.ignoreNullOrigin\n          }, options)\n        );\n      } else {\n        transport = UnsupportedStrategy;\n      }\n\n      var newContext = context.def(context, name, transport)[1];\n      newContext.transports = context.transports || {};\n      newContext.transports[name] = transport;\n      return [undefined, newContext];\n    },\n\n    transport_manager: returnWithOriginalContext(function(_, options) {\n      return new Pusher.TransportManager(options);\n    }),\n\n    sequential: returnWithOriginalContext(function(_, options) {\n      var strategies = Array.prototype.slice.call(arguments, 2);\n      return new Pusher.SequentialStrategy(strategies, options);\n    }),\n\n    cached: returnWithOriginalContext(function(context, ttl, strategy){\n      return new Pusher.CachedStrategy(strategy, context.transports, {\n        ttl: ttl,\n        timeline: context.timeline,\n        encrypted: context.encrypted\n      });\n    }),\n\n    first_connected: returnWithOriginalContext(function(_, strategy) {\n      return new Pusher.FirstConnectedStrategy(strategy);\n    }),\n\n    best_connected_ever: returnWithOriginalContext(function() {\n      var strategies = Array.prototype.slice.call(arguments, 1);\n      return new Pusher.BestConnectedEverStrategy(strategies);\n    }),\n\n    delayed: returnWithOriginalContext(function(_, delay, strategy) {\n      return new Pusher.DelayedStrategy(strategy, { delay: delay });\n    }),\n\n    \"if\": returnWithOriginalContext(function(_, test, trueBranch, falseBranch) {\n      return new Pusher.IfStrategy(test, trueBranch, falseBranch);\n    }),\n\n    is_supported: returnWithOriginalContext(function(_, strategy) {\n      return function() {\n        return strategy.isSupported();\n      };\n    })\n  };\n\n  // DSL interpreter\n\n  function isSymbol(expression) {\n    return (typeof expression === \"string\") && expression.charAt(0) === \":\";\n  }\n\n  function getSymbolValue(expression, context) {\n    return context[expression.slice(1)];\n  }\n\n  function evaluateListOfExpressions(expressions, context) {\n    if (expressions.length === 0) {\n      return [[], context];\n    }\n    var head = evaluate(expressions[0], context);\n    var tail = evaluateListOfExpressions(expressions.slice(1), head[1]);\n    return [[head[0]].concat(tail[0]), tail[1]];\n  }\n\n  function evaluateString(expression, context) {\n    if (!isSymbol(expression)) {\n      return [expression, context];\n    }\n    var value = getSymbolValue(expression, context);\n    if (value === undefined) {\n      throw \"Undefined symbol \" + expression;\n    }\n    return [value, context];\n  }\n\n  function evaluateArray(expression, context) {\n    if (isSymbol(expression[0])) {\n      var f = getSymbolValue(expression[0], context);\n      if (expression.length > 1) {\n        if (typeof f !== \"function\") {\n          throw \"Calling non-function \" + expression[0];\n        }\n        var args = [Pusher.Util.extend({}, context)].concat(\n          Pusher.Util.map(expression.slice(1), function(arg) {\n            return evaluate(arg, Pusher.Util.extend({}, context))[0];\n          })\n        );\n        return f.apply(this, args);\n      } else {\n        return [f, context];\n      }\n    } else {\n      return evaluateListOfExpressions(expression, context);\n    }\n  }\n\n  function evaluate(expression, context) {\n    var expressionType = typeof expression;\n    if (typeof expression === \"string\") {\n      return evaluateString(expression, context);\n    } else if (typeof expression === \"object\") {\n      if (expression instanceof Array && expression.length > 0) {\n        return evaluateArray(expression, context);\n      }\n    }\n    return [expression, context];\n  }\n\n  Pusher.StrategyBuilder = StrategyBuilder;\n}).call(this);\n\n;(function() {\n  /**\n   * Provides functions for handling Pusher protocol-specific messages.\n   */\n  var Protocol = {};\n\n  /**\n   * Decodes a message in a Pusher format.\n   *\n   * Throws errors when messages are not parse'able.\n   *\n   * @param  {Object} message\n   * @return {Object}\n   */\n  Protocol.decodeMessage = function(message) {\n    try {\n      var params = JSON.parse(message.data);\n      if (typeof params.data === 'string') {\n        try {\n          params.data = JSON.parse(params.data);\n        } catch (e) {\n          if (!(e instanceof SyntaxError)) {\n            // TODO looks like unreachable code\n            // https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/parse\n            throw e;\n          }\n        }\n      }\n      return params;\n    } catch (e) {\n      throw { type: 'MessageParseError', error: e, data: message.data};\n    }\n  };\n\n  /**\n   * Encodes a message to be sent.\n   *\n   * @param  {Object} message\n   * @return {String}\n   */\n  Protocol.encodeMessage = function(message) {\n    return JSON.stringify(message);\n  };\n\n  /** Processes a handshake message and returns appropriate actions.\n   *\n   * Returns an object with an 'action' and other action-specific properties.\n   *\n   * There are three outcomes when calling this function. First is a successful\n   * connection attempt, when pusher:connection_established is received, which\n   * results in a 'connected' action with an 'id' property. When passed a\n   * pusher:error event, it returns a result with action appropriate to the\n   * close code and an error. Otherwise, it raises an exception.\n   *\n   * @param {String} message\n   * @result Object\n   */\n  Protocol.processHandshake = function(message) {\n    message = this.decodeMessage(message);\n\n    if (message.event === \"pusher:connection_established\") {\n      if (!message.data.activity_timeout) {\n        throw \"No activity timeout specified in handshake\";\n      }\n      return {\n        action: \"connected\",\n        id: message.data.socket_id,\n        activityTimeout: message.data.activity_timeout * 1000\n      };\n    } else if (message.event === \"pusher:error\") {\n      // From protocol 6 close codes are sent only once, so this only\n      // happens when connection does not support close codes\n      return {\n        action: this.getCloseAction(message.data),\n        error: this.getCloseError(message.data)\n      };\n    } else {\n      throw \"Invalid handshake\";\n    }\n  };\n\n  /**\n   * Dispatches the close event and returns an appropriate action name.\n   *\n   * See:\n   * 1. https://developer.mozilla.org/en-US/docs/WebSockets/WebSockets_reference/CloseEvent\n   * 2. http://pusher.com/docs/pusher_protocol\n   *\n   * @param  {CloseEvent} closeEvent\n   * @return {String} close action name\n   */\n  Protocol.getCloseAction = function(closeEvent) {\n    if (closeEvent.code < 4000) {\n      // ignore 1000 CLOSE_NORMAL, 1001 CLOSE_GOING_AWAY,\n      //        1005 CLOSE_NO_STATUS, 1006 CLOSE_ABNORMAL\n      // ignore 1007...3999\n      // handle 1002 CLOSE_PROTOCOL_ERROR, 1003 CLOSE_UNSUPPORTED,\n      //        1004 CLOSE_TOO_LARGE\n      if (closeEvent.code >= 1002 && closeEvent.code <= 1004) {\n        return \"backoff\";\n      } else {\n        return null;\n      }\n    } else if (closeEvent.code === 4000) {\n      return \"ssl_only\";\n    } else if (closeEvent.code < 4100) {\n      return \"refused\";\n    } else if (closeEvent.code < 4200) {\n      return \"backoff\";\n    } else if (closeEvent.code < 4300) {\n      return \"retry\";\n    } else {\n      // unknown error\n      return \"refused\";\n    }\n  };\n\n  /**\n   * Returns an error or null basing on the close event.\n   *\n   * Null is returned when connection was closed cleanly. Otherwise, an object\n   * with error details is returned.\n   *\n   * @param  {CloseEvent} closeEvent\n   * @return {Object} error object\n   */\n  Protocol.getCloseError = function(closeEvent) {\n    if (closeEvent.code !== 1000 && closeEvent.code !== 1001) {\n      return {\n        type: 'PusherError',\n        data: {\n          code: closeEvent.code,\n          message: closeEvent.reason || closeEvent.message\n        }\n      };\n    } else {\n      return null;\n    }\n  };\n\n  Pusher.Protocol = Protocol;\n}).call(this);\n\n;(function() {\n  /**\n   * Provides Pusher protocol interface for transports.\n   *\n   * Emits following events:\n   * - message - on received messages\n   * - ping - on ping requests\n   * - pong - on pong responses\n   * - error - when the transport emits an error\n   * - closed - after closing the transport\n   *\n   * It also emits more events when connection closes with a code.\n   * See Protocol.getCloseAction to get more details.\n   *\n   * @param {Number} id\n   * @param {AbstractTransport} transport\n   */\n  function Connection(id, transport) {\n    Pusher.EventsDispatcher.call(this);\n\n    this.id = id;\n    this.transport = transport;\n    this.activityTimeout = transport.activityTimeout;\n    this.bindListeners();\n  }\n  var prototype = Connection.prototype;\n  Pusher.Util.extend(prototype, Pusher.EventsDispatcher.prototype);\n\n  /** Returns whether used transport handles activity checks by itself\n   *\n   * @returns {Boolean} true if activity checks are handled by the transport\n   */\n  prototype.handlesActivityChecks = function() {\n    return this.transport.handlesActivityChecks();\n  };\n\n  /** Sends raw data.\n   *\n   * @param {String} data\n   */\n  prototype.send = function(data) {\n    return this.transport.send(data);\n  };\n\n  /** Sends an event.\n   *\n   * @param {String} name\n   * @param {String} data\n   * @param {String} [channel]\n   * @returns {Boolean} whether message was sent or not\n   */\n  prototype.send_event = function(name, data, channel) {\n    var message = { event: name, data: data };\n    if (channel) {\n      message.channel = channel;\n    }\n    Pusher.debug('Event sent', message);\n    return this.send(Pusher.Protocol.encodeMessage(message));\n  };\n\n  /** Sends a ping message to the server.\n   *\n   * Basing on the underlying transport, it might send either transport's\n   * protocol-specific ping or pusher:ping event.\n   */\n  prototype.ping = function() {\n    if (this.transport.supportsPing()) {\n      this.transport.ping();\n    } else {\n      this.send_event('pusher:ping', {});\n    }\n  };\n\n  /** Closes the connection. */\n  prototype.close = function() {\n    this.transport.close();\n  };\n\n  /** @private */\n  prototype.bindListeners = function() {\n    var self = this;\n\n    var listeners = {\n      message: function(m) {\n        var message;\n        try {\n          message = Pusher.Protocol.decodeMessage(m);\n        } catch(e) {\n          self.emit('error', {\n            type: 'MessageParseError',\n            error: e,\n            data: m.data\n          });\n        }\n\n        if (message !== undefined) {\n          Pusher.debug('Event recd', message);\n\n          switch (message.event) {\n            case 'pusher:error':\n              self.emit('error', { type: 'PusherError', data: message.data });\n              break;\n            case 'pusher:ping':\n              self.emit(\"ping\");\n              break;\n            case 'pusher:pong':\n              self.emit(\"pong\");\n              break;\n          }\n          self.emit('message', message);\n        }\n      },\n      activity: function() {\n        self.emit(\"activity\");\n      },\n      error: function(error) {\n        self.emit(\"error\", { type: \"WebSocketError\", error: error });\n      },\n      closed: function(closeEvent) {\n        unbindListeners();\n\n        if (closeEvent && closeEvent.code) {\n          self.handleCloseEvent(closeEvent);\n        }\n\n        self.transport = null;\n        self.emit(\"closed\");\n      }\n    };\n\n    var unbindListeners = function() {\n      Pusher.Util.objectApply(listeners, function(listener, event) {\n        self.transport.unbind(event, listener);\n      });\n    };\n\n    Pusher.Util.objectApply(listeners, function(listener, event) {\n      self.transport.bind(event, listener);\n    });\n  };\n\n  /** @private */\n  prototype.handleCloseEvent = function(closeEvent) {\n    var action = Pusher.Protocol.getCloseAction(closeEvent);\n    var error = Pusher.Protocol.getCloseError(closeEvent);\n    if (error) {\n      this.emit('error', error);\n    }\n    if (action) {\n      this.emit(action);\n    }\n  };\n\n  Pusher.Connection = Connection;\n}).call(this);\n\n;(function() {\n  /**\n   * Handles Pusher protocol handshakes for transports.\n   *\n   * Calls back with a result object after handshake is completed. Results\n   * always have two fields:\n   * - action - string describing action to be taken after the handshake\n   * - transport - the transport object passed to the constructor\n   *\n   * Different actions can set different additional properties on the result.\n   * In the case of 'connected' action, there will be a 'connection' property\n   * containing a Connection object for the transport. Other actions should\n   * carry an 'error' property.\n   *\n   * @param {AbstractTransport} transport\n   * @param {Function} callback\n   */\n  function Handshake(transport, callback) {\n    this.transport = transport;\n    this.callback = callback;\n    this.bindListeners();\n  }\n  var prototype = Handshake.prototype;\n\n  prototype.close = function() {\n    this.unbindListeners();\n    this.transport.close();\n  };\n\n  /** @private */\n  prototype.bindListeners = function() {\n    var self = this;\n\n    self.onMessage = function(m) {\n      self.unbindListeners();\n\n      try {\n        var result = Pusher.Protocol.processHandshake(m);\n        if (result.action === \"connected\") {\n          self.finish(\"connected\", {\n            connection: new Pusher.Connection(result.id, self.transport),\n            activityTimeout: result.activityTimeout\n          });\n        } else {\n          self.finish(result.action, { error: result.error });\n          self.transport.close();\n        }\n      } catch (e) {\n        self.finish(\"error\", { error: e });\n        self.transport.close();\n      }\n    };\n\n    self.onClosed = function(closeEvent) {\n      self.unbindListeners();\n\n      var action = Pusher.Protocol.getCloseAction(closeEvent) || \"backoff\";\n      var error = Pusher.Protocol.getCloseError(closeEvent);\n      self.finish(action, { error: error });\n    };\n\n    self.transport.bind(\"message\", self.onMessage);\n    self.transport.bind(\"closed\", self.onClosed);\n  };\n\n  /** @private */\n  prototype.unbindListeners = function() {\n    this.transport.unbind(\"message\", this.onMessage);\n    this.transport.unbind(\"closed\", this.onClosed);\n  };\n\n  /** @private */\n  prototype.finish = function(action, params) {\n    this.callback(\n      Pusher.Util.extend({ transport: this.transport, action: action }, params)\n    );\n  };\n\n  Pusher.Handshake = Handshake;\n}).call(this);\n\n;(function() {\n  /** Manages connection to Pusher.\n   *\n   * Uses a strategy (currently only default), timers and network availability\n   * info to establish a connection and export its state. In case of failures,\n   * manages reconnection attempts.\n   *\n   * Exports state changes as following events:\n   * - \"state_change\", { previous: p, current: state }\n   * - state\n   *\n   * States:\n   * - initialized - initial state, never transitioned to\n   * - connecting - connection is being established\n   * - connected - connection has been fully established\n   * - disconnected - on requested disconnection\n   * - unavailable - after connection timeout or when there's no network\n   * - failed - when the connection strategy is not supported\n   *\n   * Options:\n   * - unavailableTimeout - time to transition to unavailable state\n   * - activityTimeout - time after which ping message should be sent\n   * - pongTimeout - time for Pusher to respond with pong before reconnecting\n   *\n   * @param {String} key application key\n   * @param {Object} options\n   */\n  function ConnectionManager(key, options) {\n    Pusher.EventsDispatcher.call(this);\n\n    this.key = key;\n    this.options = options || {};\n    this.state = \"initialized\";\n    this.connection = null;\n    this.encrypted = !!options.encrypted;\n    this.timeline = this.options.timeline;\n\n    this.connectionCallbacks = this.buildConnectionCallbacks();\n    this.errorCallbacks = this.buildErrorCallbacks();\n    this.handshakeCallbacks = this.buildHandshakeCallbacks(this.errorCallbacks);\n\n    var self = this;\n\n    Pusher.Network.bind(\"online\", function() {\n      self.timeline.info({ netinfo: \"online\" });\n      if (self.state === \"connecting\" || self.state === \"unavailable\") {\n        self.retryIn(0);\n      }\n    });\n    Pusher.Network.bind(\"offline\", function() {\n      self.timeline.info({ netinfo: \"offline\" });\n      if (self.connection) {\n        self.sendActivityCheck();\n      }\n    });\n\n    this.updateStrategy();\n  }\n  var prototype = ConnectionManager.prototype;\n\n  Pusher.Util.extend(prototype, Pusher.EventsDispatcher.prototype);\n\n  /** Establishes a connection to Pusher.\n   *\n   * Does nothing when connection is already established. See top-level doc\n   * to find events emitted on connection attempts.\n   */\n  prototype.connect = function() {\n    if (this.connection || this.runner) {\n      return;\n    }\n    if (!this.strategy.isSupported()) {\n      this.updateState(\"failed\");\n      return;\n    }\n    this.updateState(\"connecting\");\n    this.startConnecting();\n    this.setUnavailableTimer();\n  };\n\n  /** Sends raw data.\n   *\n   * @param {String} data\n   */\n  prototype.send = function(data) {\n    if (this.connection) {\n      return this.connection.send(data);\n    } else {\n      return false;\n    }\n  };\n\n  /** Sends an event.\n   *\n   * @param {String} name\n   * @param {String} data\n   * @param {String} [channel]\n   * @returns {Boolean} whether message was sent or not\n   */\n  prototype.send_event = function(name, data, channel) {\n    if (this.connection) {\n      return this.connection.send_event(name, data, channel);\n    } else {\n      return false;\n    }\n  };\n\n  /** Closes the connection. */\n  prototype.disconnect = function() {\n    this.disconnectInternally();\n    this.updateState(\"disconnected\");\n  };\n\n  prototype.isEncrypted = function() {\n    return this.encrypted;\n  };\n\n  /** @private */\n  prototype.startConnecting = function() {\n    var self = this;\n    var callback = function(error, handshake) {\n      if (error) {\n        self.runner = self.strategy.connect(0, callback);\n      } else {\n        if (handshake.action === \"error\") {\n          self.emit(\"error\", { type: \"HandshakeError\", error: handshake.error });\n          self.timeline.error({ handshakeError: handshake.error });\n        } else {\n          self.abortConnecting(); // we don't support switching connections yet\n          self.handshakeCallbacks[handshake.action](handshake);\n        }\n      }\n    };\n    self.runner = self.strategy.connect(0, callback);\n  };\n\n  /** @private */\n  prototype.abortConnecting = function() {\n    if (this.runner) {\n      this.runner.abort();\n      this.runner = null;\n    }\n  };\n\n  /** @private */\n  prototype.disconnectInternally = function() {\n    this.abortConnecting();\n    this.clearRetryTimer();\n    this.clearUnavailableTimer();\n    if (this.connection) {\n      var connection = this.abandonConnection();\n      connection.close();\n    }\n  };\n\n  /** @private */\n  prototype.updateStrategy = function() {\n    this.strategy = this.options.getStrategy({\n      key: this.key,\n      timeline: this.timeline,\n      encrypted: this.encrypted\n    });\n  };\n\n  /** @private */\n  prototype.retryIn = function(delay) {\n    var self = this;\n    self.timeline.info({ action: \"retry\", delay: delay });\n    if (delay > 0) {\n      self.emit(\"connecting_in\", Math.round(delay / 1000));\n    }\n    self.retryTimer = new Pusher.Timer(delay || 0, function() {\n      self.disconnectInternally();\n      self.connect();\n    });\n  };\n\n  /** @private */\n  prototype.clearRetryTimer = function() {\n    if (this.retryTimer) {\n      this.retryTimer.ensureAborted();\n      this.retryTimer = null;\n    }\n  };\n\n  /** @private */\n  prototype.setUnavailableTimer = function() {\n    var self = this;\n    self.unavailableTimer = new Pusher.Timer(\n      self.options.unavailableTimeout,\n      function() {\n        self.updateState(\"unavailable\");\n      }\n    );\n  };\n\n  /** @private */\n  prototype.clearUnavailableTimer = function() {\n    if (this.unavailableTimer) {\n      this.unavailableTimer.ensureAborted();\n    }\n  };\n\n  /** @private */\n  prototype.sendActivityCheck = function() {\n    var self = this;\n    self.stopActivityCheck();\n    self.connection.ping();\n    // wait for pong response\n    self.activityTimer = new Pusher.Timer(\n      self.options.pongTimeout,\n      function() {\n        self.timeline.error({ pong_timed_out: self.options.pongTimeout });\n        self.retryIn(0);\n      }\n    );\n  };\n\n  /** @private */\n  prototype.resetActivityCheck = function() {\n    var self = this;\n    self.stopActivityCheck();\n    // send ping after inactivity\n    if (!self.connection.handlesActivityChecks()) {\n      self.activityTimer = new Pusher.Timer(self.activityTimeout, function() {\n        self.sendActivityCheck();\n      });\n    }\n  };\n\n  /** @private */\n  prototype.stopActivityCheck = function() {\n    if (this.activityTimer) {\n      this.activityTimer.ensureAborted();\n    }\n  };\n\n  /** @private */\n  prototype.buildConnectionCallbacks = function() {\n    var self = this;\n    return {\n      message: function(message) {\n        // includes pong messages from server\n        self.resetActivityCheck();\n        self.emit('message', message);\n      },\n      ping: function() {\n        self.send_event('pusher:pong', {});\n      },\n      activity: function() {\n        self.resetActivityCheck();\n      },\n      error: function(error) {\n        // just emit error to user - socket will already be closed by browser\n        self.emit(\"error\", { type: \"WebSocketError\", error: error });\n      },\n      closed: function() {\n        self.abandonConnection();\n        if (self.shouldRetry()) {\n          self.retryIn(1000);\n        }\n      }\n    };\n  };\n\n  /** @private */\n  prototype.buildHandshakeCallbacks = function(errorCallbacks) {\n    var self = this;\n    return Pusher.Util.extend({}, errorCallbacks, {\n      connected: function(handshake) {\n        self.activityTimeout = Math.min(\n          self.options.activityTimeout,\n          handshake.activityTimeout,\n          handshake.connection.activityTimeout || Infinity\n        );\n        self.clearUnavailableTimer();\n        self.setConnection(handshake.connection);\n        self.socket_id = self.connection.id;\n        self.updateState(\"connected\", { socket_id: self.socket_id });\n      }\n    });\n  };\n\n  /** @private */\n  prototype.buildErrorCallbacks = function() {\n    var self = this;\n\n    function withErrorEmitted(callback) {\n      return function(result) {\n        if (result.error) {\n          self.emit(\"error\", { type: \"WebSocketError\", error: result.error });\n        }\n        callback(result);\n      };\n    }\n\n    return {\n      ssl_only: withErrorEmitted(function() {\n        self.encrypted = true;\n        self.updateStrategy();\n        self.retryIn(0);\n      }),\n      refused: withErrorEmitted(function() {\n        self.disconnect();\n      }),\n      backoff: withErrorEmitted(function() {\n        self.retryIn(1000);\n      }),\n      retry: withErrorEmitted(function() {\n        self.retryIn(0);\n      })\n    };\n  };\n\n  /** @private */\n  prototype.setConnection = function(connection) {\n    this.connection = connection;\n    for (var event in this.connectionCallbacks) {\n      this.connection.bind(event, this.connectionCallbacks[event]);\n    }\n    this.resetActivityCheck();\n  };\n\n  /** @private */\n  prototype.abandonConnection = function() {\n    if (!this.connection) {\n      return;\n    }\n    this.stopActivityCheck();\n    for (var event in this.connectionCallbacks) {\n      this.connection.unbind(event, this.connectionCallbacks[event]);\n    }\n    var connection = this.connection;\n    this.connection = null;\n    return connection;\n  };\n\n  /** @private */\n  prototype.updateState = function(newState, data) {\n    var previousState = this.state;\n    this.state = newState;\n    if (previousState !== newState) {\n      Pusher.debug('State changed', previousState + ' -> ' + newState);\n      this.timeline.info({ state: newState, params: data });\n      this.emit('state_change', { previous: previousState, current: newState });\n      this.emit(newState, data);\n    }\n  };\n\n  /** @private */\n  prototype.shouldRetry = function() {\n    return this.state === \"connecting\" || this.state === \"connected\";\n  };\n\n  Pusher.ConnectionManager = ConnectionManager;\n}).call(this);\n\n;(function() {\n  /** Really basic interface providing network availability info.\n   *\n   * Emits:\n   * - online - when browser goes online\n   * - offline - when browser goes offline\n   */\n  function NetInfo() {\n    Pusher.EventsDispatcher.call(this);\n\n    var self = this;\n    // This is okay, as IE doesn't support this stuff anyway.\n    if (window.addEventListener !== undefined) {\n      window.addEventListener(\"online\", function() {\n        self.emit('online');\n      }, false);\n      window.addEventListener(\"offline\", function() {\n        self.emit('offline');\n      }, false);\n    }\n  }\n  Pusher.Util.extend(NetInfo.prototype, Pusher.EventsDispatcher.prototype);\n\n  var prototype = NetInfo.prototype;\n\n  /** Returns whether browser is online or not\n   *\n   * Offline means definitely offline (no connection to router).\n   * Inverse does NOT mean definitely online (only currently supported in Safari\n   * and even there only means the device has a connection to the router).\n   *\n   * @return {Boolean}\n   */\n  prototype.isOnline = function() {\n    if (window.navigator.onLine === undefined) {\n      return true;\n    } else {\n      return window.navigator.onLine;\n    }\n  };\n\n  Pusher.NetInfo = NetInfo;\n  Pusher.Network = new NetInfo();\n}).call(this);\n\n;(function() {\n  /** Represents a collection of members of a presence channel. */\n  function Members() {\n    this.reset();\n  }\n  var prototype = Members.prototype;\n\n  /** Returns member's info for given id.\n   *\n   * Resulting object containts two fields - id and info.\n   *\n   * @param {Number} id\n   * @return {Object} member's info or null\n   */\n  prototype.get = function(id) {\n    if (Object.prototype.hasOwnProperty.call(this.members, id)) {\n      return {\n        id: id,\n        info: this.members[id]\n      };\n    } else {\n      return null;\n    }\n  };\n\n  /** Calls back for each member in unspecified order.\n   *\n   * @param  {Function} callback\n   */\n  prototype.each = function(callback) {\n    var self = this;\n    Pusher.Util.objectApply(self.members, function(member, id) {\n      callback(self.get(id));\n    });\n  };\n\n  /** Updates the id for connected member. For internal use only. */\n  prototype.setMyID = function(id) {\n    this.myID = id;\n  };\n\n  /** Handles subscription data. For internal use only. */\n  prototype.onSubscription = function(subscriptionData) {\n    this.members = subscriptionData.presence.hash;\n    this.count = subscriptionData.presence.count;\n    this.me = this.get(this.myID);\n  };\n\n  /** Adds a new member to the collection. For internal use only. */\n  prototype.addMember = function(memberData) {\n    if (this.get(memberData.user_id) === null) {\n      this.count++;\n    }\n    this.members[memberData.user_id] = memberData.user_info;\n    return this.get(memberData.user_id);\n  };\n\n  /** Adds a member from the collection. For internal use only. */\n  prototype.removeMember = function(memberData) {\n    var member = this.get(memberData.user_id);\n    if (member) {\n      delete this.members[memberData.user_id];\n      this.count--;\n    }\n    return member;\n  };\n\n  /** Resets the collection to the initial state. For internal use only. */\n  prototype.reset = function() {\n    this.members = {};\n    this.count = 0;\n    this.myID = null;\n    this.me = null;\n  };\n\n  Pusher.Members = Members;\n}).call(this);\n\n;(function() {\n  /** Provides base public channel interface with an event emitter.\n   *\n   * Emits:\n   * - pusher:subscription_succeeded - after subscribing successfully\n   * - other non-internal events\n   *\n   * @param {String} name\n   * @param {Pusher} pusher\n   */\n  function Channel(name, pusher) {\n    Pusher.EventsDispatcher.call(this, function(event, data) {\n      Pusher.debug('No callbacks on ' + name + ' for ' + event);\n    });\n\n    this.name = name;\n    this.pusher = pusher;\n    this.subscribed = false;\n  }\n  var prototype = Channel.prototype;\n  Pusher.Util.extend(prototype, Pusher.EventsDispatcher.prototype);\n\n  /** Skips authorization, since public channels don't require it.\n   *\n   * @param {Function} callback\n   */\n  prototype.authorize = function(socketId, callback) {\n    return callback(false, {});\n  };\n\n  /** Triggers an event */\n  prototype.trigger = function(event, data) {\n    if (event.indexOf(\"client-\") !== 0) {\n      throw new Pusher.Errors.BadEventName(\n        \"Event '\" + event + \"' does not start with 'client-'\"\n      );\n    }\n    return this.pusher.send_event(event, data, this.name);\n  };\n\n  /** Signals disconnection to the channel. For internal use only. */\n  prototype.disconnect = function() {\n    this.subscribed = false;\n  };\n\n  /** Handles an event. For internal use only.\n   *\n   * @param {String} event\n   * @param {*} data\n   */\n  prototype.handleEvent = function(event, data) {\n    if (event.indexOf(\"pusher_internal:\") === 0) {\n      if (event === \"pusher_internal:subscription_succeeded\") {\n        this.subscribed = true;\n        this.emit(\"pusher:subscription_succeeded\", data);\n      }\n    } else {\n      this.emit(event, data);\n    }\n  };\n\n  /** Sends a subscription request. For internal use only. */\n  prototype.subscribe = function() {\n    var self = this;\n\n    self.authorize(self.pusher.connection.socket_id, function(error, data) {\n      if (error) {\n        self.handleEvent('pusher:subscription_error', data);\n      } else {\n        self.pusher.send_event('pusher:subscribe', {\n          auth: data.auth,\n          channel_data: data.channel_data,\n          channel: self.name\n        });\n      }\n    });\n  };\n\n  /** Sends an unsubscription request. For internal use only. */\n  prototype.unsubscribe = function() {\n    this.pusher.send_event('pusher:unsubscribe', {\n      channel: this.name\n    });\n  };\n\n  Pusher.Channel = Channel;\n}).call(this);\n\n;(function() {\n  /** Extends public channels to provide private channel interface.\n   *\n   * @param {String} name\n   * @param {Pusher} pusher\n   */\n  function PrivateChannel(name, pusher) {\n    Pusher.Channel.call(this, name, pusher);\n  }\n  var prototype = PrivateChannel.prototype;\n  Pusher.Util.extend(prototype, Pusher.Channel.prototype);\n\n  /** Authorizes the connection to use the channel.\n   *\n   * @param  {String} socketId\n   * @param  {Function} callback\n   */\n  prototype.authorize = function(socketId, callback) {\n    var authorizer = new Pusher.Channel.Authorizer(this, this.pusher.config);\n    return authorizer.authorize(socketId, callback);\n  };\n\n  Pusher.PrivateChannel = PrivateChannel;\n}).call(this);\n\n;(function() {\n  /** Adds presence channel functionality to private channels.\n   *\n   * @param {String} name\n   * @param {Pusher} pusher\n   */\n  function PresenceChannel(name, pusher) {\n    Pusher.PrivateChannel.call(this, name, pusher);\n    this.members = new Pusher.Members();\n  }\n  var prototype = PresenceChannel.prototype;\n  Pusher.Util.extend(prototype, Pusher.PrivateChannel.prototype);\n\n  /** Authenticates the connection as a member of the channel.\n   *\n   * @param  {String} socketId\n   * @param  {Function} callback\n   */\n  prototype.authorize = function(socketId, callback) {\n    var _super = Pusher.PrivateChannel.prototype.authorize;\n    var self = this;\n    _super.call(self, socketId, function(error, authData) {\n      if (!error) {\n        if (authData.channel_data === undefined) {\n          Pusher.warn(\n            \"Invalid auth response for channel '\" +\n            self.name +\n            \"', expected 'channel_data' field\"\n          );\n          callback(\"Invalid auth response\");\n          return;\n        }\n        var channelData = JSON.parse(authData.channel_data);\n        self.members.setMyID(channelData.user_id);\n      }\n      callback(error, authData);\n    });\n  };\n\n  /** Handles presence and subscription events. For internal use only.\n   *\n   * @param {String} event\n   * @param {*} data\n   */\n  prototype.handleEvent = function(event, data) {\n    switch (event) {\n      case \"pusher_internal:subscription_succeeded\":\n        this.members.onSubscription(data);\n        this.subscribed = true;\n        this.emit(\"pusher:subscription_succeeded\", this.members);\n        break;\n      case \"pusher_internal:member_added\":\n        var addedMember = this.members.addMember(data);\n        this.emit('pusher:member_added', addedMember);\n        break;\n      case \"pusher_internal:member_removed\":\n        var removedMember = this.members.removeMember(data);\n        if (removedMember) {\n          this.emit('pusher:member_removed', removedMember);\n        }\n        break;\n      default:\n        Pusher.PrivateChannel.prototype.handleEvent.call(this, event, data);\n    }\n  };\n\n  /** Resets the channel state, including members map. For internal use only. */\n  prototype.disconnect = function() {\n    this.members.reset();\n    Pusher.PrivateChannel.prototype.disconnect.call(this);\n  };\n\n  Pusher.PresenceChannel = PresenceChannel;\n}).call(this);\n\n;(function() {\n  /** Handles a channel map. */\n  function Channels() {\n    this.channels = {};\n  }\n  var prototype = Channels.prototype;\n\n  /** Creates or retrieves an existing channel by its name.\n   *\n   * @param {String} name\n   * @param {Pusher} pusher\n   * @return {Channel}\n   */\n  prototype.add = function(name, pusher) {\n    if (!this.channels[name]) {\n      this.channels[name] = createChannel(name, pusher);\n    }\n    return this.channels[name];\n  };\n\n  /** Returns a list of all channels\n   *\n   * @return {Array}\n   */\n  prototype.all = function(name) {\n    return Pusher.Util.values(this.channels);\n  };\n\n  /** Finds a channel by its name.\n   *\n   * @param {String} name\n   * @return {Channel} channel or null if it doesn't exist\n   */\n  prototype.find = function(name) {\n    return this.channels[name];\n  };\n\n  /** Removes a channel from the map.\n   *\n   * @param {String} name\n   */\n  prototype.remove = function(name) {\n    var channel = this.channels[name];\n    delete this.channels[name];\n    return channel;\n  };\n\n  /** Proxies disconnection signal to all channels. */\n  prototype.disconnect = function() {\n    Pusher.Util.objectApply(this.channels, function(channel) {\n      channel.disconnect();\n    });\n  };\n\n  function createChannel(name, pusher) {\n    if (name.indexOf('private-') === 0) {\n      return new Pusher.PrivateChannel(name, pusher);\n    } else if (name.indexOf('presence-') === 0) {\n      return new Pusher.PresenceChannel(name, pusher);\n    } else {\n      return new Pusher.Channel(name, pusher);\n    }\n  }\n\n  Pusher.Channels = Channels;\n}).call(this);\n\n;(function() {\n  Pusher.Channel.Authorizer = function(channel, options) {\n    this.channel = channel;\n    this.type = options.authTransport;\n\n    this.options = options;\n    this.authOptions = (options || {}).auth || {};\n  };\n\n  Pusher.Channel.Authorizer.prototype = {\n    composeQuery: function(socketId) {\n      var query = 'socket_id=' + encodeURIComponent(socketId) +\n        '&channel_name=' + encodeURIComponent(this.channel.name);\n\n      for(var i in this.authOptions.params) {\n        query += \"&\" + encodeURIComponent(i) + \"=\" + encodeURIComponent(this.authOptions.params[i]);\n      }\n\n      return query;\n    },\n\n    authorize: function(socketId, callback) {\n      return Pusher.authorizers[this.type].call(this, socketId, callback);\n    }\n  };\n\n  var nextAuthCallbackID = 1;\n\n  Pusher.auth_callbacks = {};\n  Pusher.authorizers = {\n    ajax: function(socketId, callback){\n      var self = this, xhr;\n\n      if (Pusher.XHR) {\n        xhr = new Pusher.XHR();\n      } else {\n        xhr = (window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject(\"Microsoft.XMLHTTP\"));\n      }\n\n      xhr.open(\"POST\", self.options.authEndpoint, true);\n\n      // add request headers\n      xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n      for(var headerName in this.authOptions.headers) {\n        xhr.setRequestHeader(headerName, this.authOptions.headers[headerName]);\n      }\n\n      xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n          if (xhr.status === 200) {\n            var data, parsed = false;\n\n            try {\n              data = JSON.parse(xhr.responseText);\n              parsed = true;\n            } catch (e) {\n              callback(true, 'JSON returned from webapp was invalid, yet status code was 200. Data was: ' + xhr.responseText);\n            }\n\n            if (parsed) { // prevents double execution.\n              callback(false, data);\n            }\n          } else {\n            Pusher.warn(\"Couldn't get auth info from your webapp\", xhr.status);\n            callback(true, xhr.status);\n          }\n        }\n      };\n\n      xhr.send(this.composeQuery(socketId));\n      return xhr;\n    },\n\n    jsonp: function(socketId, callback){\n      if(this.authOptions.headers !== undefined) {\n        Pusher.warn(\"Warn\", \"To send headers with the auth request, you must use AJAX, rather than JSONP.\");\n      }\n\n      var callbackName = nextAuthCallbackID.toString();\n      nextAuthCallbackID++;\n\n      var document = Pusher.Util.getDocument();\n      var script = document.createElement(\"script\");\n      // Hacked wrapper.\n      Pusher.auth_callbacks[callbackName] = function(data) {\n        callback(false, data);\n      };\n\n      var callback_name = \"Pusher.auth_callbacks['\" + callbackName + \"']\";\n      script.src = this.options.authEndpoint +\n        '?callback=' +\n        encodeURIComponent(callback_name) +\n        '&' +\n        this.composeQuery(socketId);\n\n      var head = document.getElementsByTagName(\"head\")[0] || document.documentElement;\n      head.insertBefore( script, head.firstChild );\n    }\n  };\n}).call(this);\n\nreturn Pusher;\n}));\n\n"],"sourceRoot":"/source/"}