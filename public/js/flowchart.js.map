{"version":3,"sources":["flowchart.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"flowchart.js","sourcesContent":["/**\n * Flowchart system for K-State Engineering Advising system\n * \n * @author Russell Feldhausen russfeld@ksu.edu\n * @license none specified; uses Snap.svg.js which is licensed under the Apache License V 2.0\n */\n\nvar flowchart = {\n    s: {},                  //global snap.svg.js element\n    debug: function(text){  //global debugging function\n        //comment out the next line to disable debugs, or remove this function def entirely\n        console.log(\"flowchart.js: \" + text);\n    },            \n    \n    settings: {             //application drawing settings\n        chart: {                  //size settings for drawing flowcharts\n            boxHeight: 50,          //flowchart box height\n            boxWidth: 100,          //flowchart box width\n            horizSpacing: 20,       //horizontal spacing between boxes\n            vertSpacing: 20,        //vertical spacing between boxes\n            dropBoxOffset: 5,       //how much larger in each direction the drop boxes are\n            dropBoxRadius: 5,       //radius of the corners on the drop boxes\n            toolboxLeft: 0,         //size of the toolbox at left (calculated at init)\n            menuTop: 0,             //size of the menu at the top (calculated at init)\n            animationSpeed: 100     //speed of the drop animations\n        },\n        toolbox: {              //size settings for the toolbox\n            toolHeight: 50,         //height of each tool object\n            toolWidth: 100,         //width of each tool object\n            vertSpacing: 20,        //vertical spacing between tools\n            toolRightGutter: 20     //gutter between the toolbox and the flowchart\n        },\n        forces: {               //constants used in the force-directed line spacing algorithm\n            c1: 1,                  //scale of the force magnitude between lines\n            c2: 20,                 //numerator of the force division between lines (distance must be less than this this to trigger a force), recommend using horizSpacing from above\n            c3: 0.1,                //scale of the overall force applied as movement\n            c4: 0.01,               //scale of the force applied based on direction of attached lines\n            c5: 900,                //numerator of the force division based on attached lines (distance must be less than this to trigger a force)\n            c6: 0.5,                //scale of the force applied based on the channels                 \n            c7: 15,                 //numerator of the force division based on attached lines (distance must be less than this to trigger a force)\n            t: 1                    //the maximum force must be at least this high to trigger another iteration\n        },\n        viewBoxWidth: 1200,     //height of the resulting SVG image\n        viewBoxHeight: 900      //width of the resulting SVG image\n    },\n\n    config: {               //user-changeable configuration settings with default values\n        drawToolbox: false,     //enable or disable drawing the toolbox (overrides draggable)\n        draggable: false,       //enable or disable draggable flowchart boxes   \n        gridRows: 8,            //number of rows in the flowchart\n        gridCols: 8             //number of columns in the flowchart\n    },\n    \n    data: {                 //essential flowchart data\n        boxes: [],              //array of flowchart boxes\n        lines: [],              //array of flowchart lines\n        drops: [],              //array of flowchart drop zones\n        tools: {                //toolbox tools\n            boxTool: {},            //toolbox box tool (for dragging/dropping)\n            arrowTool: {}           //toolbox arrow tool (for drawing arrows)\n        }\n    },\n    \n    runtime: {              //data stored at runtime only with default values\n        scale: 1,               //current scale of the SVG within the frame\n        boxSelected: -1,        //array index of current box selected\n        dropZoneX: -1,          //x grid coordinate of the current drop zone\n        dropZoneY: -1,          //y grid coordinate of the current drop zone\n        dragInitialX: -1,       //initial x coordinate of the box being dragged\n        dragInitialY: -1,       //initial y coordinate of the box being dragged\n        boundingBox: {}         //variable to store the flowchart's bounding box for drag checks\n    },\n    \n    /**\n     * Function to initialize the Flowchart application\n     * \n     * @param {string} element - A CSS ID representing the SVG DOM element to be used\n     * @param {object} overrideConfig - an object containing properties to be overridden at runtime \n     * (see flowchart.config above for settings that can be overridden this way)\n     */\n    init: function(element, overrideConfig){\n        //create a new SVG element and set attributes\n        var svgElem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n        svgElem.setAttribute(\"id\", \"svg\");\n        //svgElem.setAttribute(\"height\", \"100%\");\n        svgElem.setAttribute(\"width\", \"100%\");\n\n        //get the parent container\n        var parent = document.getElementById(element);\n\n        //append the new SVG element within that element\n        parent.appendChild(svgElem);\n\n        //Initialize snap.svg.js\n        flowchart.s = Snap(\"#svg\");\n\n        //Add the global flowchart CSS class to the new SVG element\n        flowchart.s.addClass(\"flowchart\");\n\n        //override default configuration with provided configuration\n        if(overrideConfig !== undefined){\n            for(var property in overrideConfig){\n                //check to see if property is not inherited\n                if(overrideConfig.hasOwnProperty(property)){\n                    flowchart.config[property] = overrideConfig[property];\n                }\n            }\n        }\n\n        //draw toolbox if needed\n        if(flowchart.config.drawToolbox){\n            flowchart.ops.drawToolbox();\n        }\n\n        //draw the drop zones\n        flowchart.ops.drawDropZones();\n\n        //draw the flowchart boxes\n        flowchart.ops.drawFlowchartBoxes();\n\n        //draw any needed prereq lines\n        flowchart.ops.drawFlowchartLines();\n\n        //update the viewBox now that the SVG has been drawn\n        flowchart.utils.updateViewBox();\n\n        //calculate the new scaling value\n        flowchart.utils.updateScale();\n\n        //register an event handler on window resize to update the scale value accordingly\n        flowchart.utils.addEvent(window, \"resize\", flowchart.utils.updateScale);\n    },\n\n    //Class Definitions\n    classes: {\n        /**\n         * Class for representing boxes (classes) on the flowchart\n         */\n        flowchartBox: function(){\n            this.flowX = -1;            //x coordinate of the box on the grid (not pixels)\n            this.flowY = -1;            //y coordinate of the box on the grid (not pixels)\n            this.flowID = -1;           //position of the object in the data array\n            this.svgElem = {};          //svg element of the box within the image\n            this.lines = [];            //array of lines connecting to this object\n        },\n\n        /**\n         * Class for representing lines (prerequisite arrows) on the flowchart\n         */\n        flowchartLine: function(){\n            this.startBoxID = -1;       //the ID of the flowchart box at the start of the line\n            this.endBoxID = -1;         //the ID of the flowchart box at the end of the line\n            this.firstX = -1;           //the X coorindate of the side of the first box\n            this.startX = -1;           //the X coordinate of the starting point\n            this.startY = -1;           //the Y coordinate of the starting point\n            this.mainY = -1;            //the Y coordinate of the main line\n            this.endX = -1;             //the X coordinate of the ending point\n            this.endY = -1;             //the Y coordinate of the ending point\n            this.lastX = -1;            //the X coordinate of the side of the last box\n            this.flowID = -1;           //the position of this line within the data array\n            this.svgElem = {};          //svg element of this line within the image\n            this.mainForce = 0;         //force acting on the main line for force directed drawing\n            this.startForce = 0;        //force acting on the starting line for force directed drawing\n            this.endForce = 0;          //force acting on the ending line for force directed drawing\n        }\n    },\n\n    //Event handlers\n    handlers: {\n        /**\n         * Function for selecting the box tool. It will enable drag/drop for the boxes on the flowchart\n         * and highlight that box.\n         */\n        boxToolSelected: function(){\n            flowchart.debug(\"boxTool selected\");\n\n            //unlink any previous click or drag events and enable dragging\n            flowchart.data.boxes.forEach(function(element){\n                element.svgElem.unclick();\n                element.svgElem.undrag();\n                element.svgElem.drag(\n                    flowchart.handlers.boxToolDragMove,         //move action handler\n                    flowchart.handlers.boxToolDragStart,        //start drag action handler\n                    flowchart.handlers.boxToolDragEnd,          //end drag action handler (release)\n                    element,                                    //move action context\n                    element,                                    //start action context\n                    element);                                   //end action context\n            });\n\n            //remove the selected class from all items on the flowchart\n            flowchart.utils.removeClassFromAll(\"selected\");\n\n            //add the selected class to the boxTool\n            flowchart.data.tools.boxTool.addClass(\"selected\");\n        },\n\n        /**\n         * Function to move flowchart boxes as the mouse moves\n         *\n         * @param {int} dx - how far the object has moved in the x direction\n         * @param {int} dy - how far the object has moved in the y direction\n         * @param {int} x - current x position of the object being moved\n         * @param {int} y - current y position of the object being moved\n         */\n        boxToolDragMove: function(dx, dy, x, y){\n            flowchart.debug(\"boxTool dragging box \" + dx + \",\" + dy + \" to \" + x + \",\" + y);\n\n            //calculate the new X position bounded by the toolbox and the edge\n            var newX = flowchart.utils.bound(\n                +flowchart.runtime.dragInitialX + (dx / flowchart.runtime.scale), \n                flowchart.settings.chart.toolboxLeft, \n                flowchart.runtime.boundingBox.width);\n\n            //calculate the new Y position bounded by the menu and the edge\n            var newY = flowchart.utils.bound(\n                +flowchart.runtime.dragInitialY + (dy / flowchart.runtime.scale), \n                flowchart.settings.chart.menuTop,\n                flowchart.runtime.boundingBox.height);\n\n            //move the object to the current mouse position\n            this.svgElem.attr({ \n                x: newX, \n                y: newY\n            });\n\n            //highlight the appropriate drop zone\n            flowchart.utils.highlightDrop(x, y);\n        },\n\n        /**\n         * Function to start dragging a flowchart box\n         * \n         * @param {int} x - the x position of the item when first clicked\n         * @param {int} y - the y position of the item when first clicked\n         */\n        boxToolDragStart: function(x, y){\n            flowchart.debug(\"boxTool start dragging box at \" + x + \",\" + y);\n\n            //store the initial position in runtime variables\n            flowchart.runtime.dragInitialX = this.svgElem.attr(\"x\");\n            flowchart.runtime.dragInitialY = this.svgElem.attr(\"y\");\n\n            flowchart.utils.highlightDrop(x, y);\n        },\n\n        /**\n         * Function called when a dragged box is released. It will settle the box on the current drop zone\n         */\n        boxToolDragEnd: function(){\n            flowchart.debug(\"boxTool end dragging\");\n\n            //drop the current object on the drop zone\n            flowchart.utils.animateToDropZone(this);\n            \n            //clear the highlighted drop zone\n            flowchart.utils.highlightDropClear();\n        },\n\n        /**\n         * Function for selecting the arrow tool. It will enable users to click successive boxes\n         * and create flowchart arrows between them\n         */\n        arrowToolSelected: function(){\n            flowchart.debug(\"arrowTool selected\");\n\n            //unlink any previous click or drag events and enable clicking\n            flowchart.data.boxes.forEach(function(element){\n                element.svgElem.unclick();\n                element.svgElem.undrag();\n                element.svgElem.click(flowchart.handlers.arrowToolClick);\n            });\n\n            //remove the selected class from all items on the flowchart\n            flowchart.utils.removeClassFromAll(\"selected\");\n\n            //add the selected class to the boxTool\n            flowchart.data.tools.arrowTool.addClass(\"selected\");\n\n            //clear selected box variable\n            flowchart.runtime.boxSelected = -1;\n        },\n\n        /**\n         * This function is called when a user clicks a box while the arrow tool is selected.\n         * The first box clicked will be highlighted, the second box clicked will cause\n         * an arrow to be created between the boxes\n         */\n        arrowToolClick: function(){\n            var fromBox;\n            //If a box is already selected, draw an arrow between the two boxes\n            if(boxSelected > 0){\n                fromBox = flowchart.data.boxes[boxSelected];\n                flowchart.debug(\"drawing arrow from box at \" + fromBox.flow_x + \",\" + fromBox.flow_y + \n                    \" to box at \" + this.flow_x + \",\" + this.flow_y);\n            //if no box is selected, select the current one\n            }else{\n                flowchart.debug(\"arrowTool selecting box at \" + this.flow_x + \",\" + this.flow_y);\n                boxSelected = this.flow_id;\n            }\n        }\n\n\n    },\n    \n    //main operations and functions\n    ops: {                  \n        /**\n         * Function to draw the toolbox used for creating the flowcharts on the left side of the flowchart window\n         */\n        drawToolbox: function(){\n            //Alias for the flowchart settings area for code readability\n            var fst = flowchart.settings.toolbox;\n\n            //Box tool\n            flowchart.data.tools.boxTool = flowchart.s.rect(\n                0, 0, \n                fst.toolWidth, fst.toolHeight);\n            flowchart.data.tools.boxTool.addClass(\"boxTool\");\n\n            //Arrow Tool\n            flowchart.data.tools.arrowTool = flowchart.s.rect(\n                0, fst.toolHeight + fst.vertSpacing, \n                fst.toolWidth, fst.toolHeight);\n            flowchart.data.tools.arrowTool.addClass(\"arrowTool\");\n\n            //Arrow Tool Line\n            flowchart.s.polyline(\n                0, fst.toolHeight + fst.vertSpacing, \n                fst.toolWidth, fst.toolHeight + fst.vertSpacing + fst.toolHeight)\n                .addClass(\"arrowToolLine\");\n\n            //Bind click handlers\n            flowchart.data.tools.boxTool.click(flowchart.handlers.boxToolSelected);\n            flowchart.data.tools.arrowTool.click(flowchart.handlers.arrowToolSelected);\n\n            //update size settings\n            flowchart.settings.chart.toolboxLeft = fst.toolWidth + fst.toolRightGutter;\n        },\n\n        /**\n         * Function to draw the drop zone boxes on the flowchart\n         */\n        drawDropZones: function(){\n            //Alias for the flowchart settings for code readability\n            var fsc = flowchart.settings.chart;\n\n            //iterator variables\n            var i, j;\n\n            for(i = 0; i < flowchart.config.gridRows; i++){\n                //initialize each row of the drops array\n                flowchart.data.drops[i] = [];\n\n                for(j = 0; j < flowchart.config.gridCols; j++){\n                    flowchart.data.drops[i][j] = flowchart.s.rect(\n                        fsc.toolboxLeft + (i * (fsc.boxWidth + fsc.horizSpacing)), fsc.menuTop + (j * (fsc.boxHeight + fsc.vertSpacing)), \n                        fsc.boxWidth, fsc.boxHeight, \n                        fsc.dropBoxRadius, fsc.dropBoxRadius);\n                    flowchart.data.drops[i][j].addClass(\"dropZone\");\n                }\n            }\n        },\n\n        /**\n         * Function to draw the flowchart boxes on the flowchart\n         */\n        drawFlowchartBoxes: function(){\n            //Alias for the flowchart settings for code readability\n            var fsc = flowchart.settings.chart;\n\n            //iterator variables\n            var i;\n\n            //for now, draw 4 boxes for testing\n            for(i = 0; i < 8; i++){\n                flowchart.data.boxes[i] = new flowchart.classes.flowchartBox();\n                flowchart.data.boxes[i].svgElem = flowchart.s.rect(\n                    fsc.toolboxLeft + fsc.dropBoxOffset + (i * (fsc.boxWidth + fsc.horizSpacing)), fsc.menuTop + fsc.dropBoxOffset + (2 * (fsc.boxHeight + fsc.horizSpacing)), \n                    fsc.boxWidth - fsc.dropBoxOffset - fsc.dropBoxOffset, fsc.boxHeight - fsc.dropBoxOffset - fsc.dropBoxOffset);\n                flowchart.data.boxes[i].svgElem.addClass(\"box\");\n\n                //update variables for the location of the box in the grid, and its ID\n                flowchart.data.boxes[i].flowX = 0;\n                flowchart.data.boxes[i].flowY = 2 * i;\n                flowchart.data.boxes[i].flowID = i;\n\n                //add a variable to the SVG element attributes to help with tracking it in click handlers\n                flowchart.data.boxes[i].svgElem.flowID = i;\n            }\n        },\n\n        /**\n         * This function will update a line to connect with its flowchart boxes after being created or moved\n         *\n         * @param line (flowchartLine object) - the line to be updated\n         */\n        updateLine: function(line){\n            //get bounding boxes for each box\n            var bbox1 = flowchart.data.boxes[line.startBoxID].svgElem.getBBox();\n            var bbox2 = flowchart.data.boxes[line.endBoxID].svgElem.getBBox();\n\n            //alias\n            var fsc = flowchart.settings.chart;\n\n            //set line points\n            line.firstX = bbox1.x2;\n            line.startX = bbox1.x2 + fsc.dropBoxOffset + (fsc.horizSpacing / 3);\n            line.startY = bbox1.cy;\n            line.endX = bbox2.x - fsc.dropBoxOffset - (fsc.horizSpacing / 3);\n            line.endY = bbox2.cy;\n            line.lastX = bbox2.x;\n\n            //determine initial direction of line\n            if(line.startY < line.endY){ //if the starting box is above the ending box, go below\n                line.mainY = bbox1.y2 + fsc.dropBoxOffset + (fsc.vertSpacing / 2);\n            }else{ //if not, go above\n                line.mainY = bbox1.y - fsc.dropBoxOffset - (fsc.vertSpacing / 2);\n            }\n\n            flowchart.ops.setLineAttrs(line);\n        },\n\n        /**\n         * This function will update the attributes of the current line to match the coordinates given\n         *\n         * @param line {flowchartLine object} - the line to be updated\n         */\n        setLineAttrs: function(line){\n            line.svgElem.attr({points: [\n                line.firstX, line.startY, \n                line.startX, line.startY, \n                line.startX, line.mainY, \n                line.endX, line.mainY, \n                line.endX, line.endY, \n                line.lastX, line.endY\n                ]});\n        },\n\n        /**\n         * Function to create a line between the boxes given on the flowchart\n         * \n         * @param box1 {flowchartBox object} - the source flowchart box\n         * @param box2 {flowchartBox object} - the destination flowchart box\n         */\n        createLine: function(box1, box2){\n            //variables\n            var line = new flowchart.classes.flowchartLine();\n            \n            //set IDs of each box in the line object\n            line.startBoxID = box1.flowID;\n            line.endBoxID = box2.flowID;\n            line.svgElem = flowchart.s.polyline();\n            line.svgElem.addClass(\"line\");\n\n            flowchart.ops.updateLine(line);\n\n            //add line to data storage areas\n            line.flowID = flowchart.data.lines.length;\n            box1.lines.push(line);\n            box2.lines.push(line);\n            flowchart.data.lines.push(line);\n\n            return line;\n        },\n\n        /**\n         * Function to create flowchart prerequisite lines\n         *\n         */\n        drawFlowchartLines: function(){\n            var i;\n\n            //for now, draw lines between varying flowchart boxes as a test\n            flowchart.ops.createLine(flowchart.data.boxes[7], flowchart.data.boxes[0]);\n            flowchart.ops.createLine(flowchart.data.boxes[0], flowchart.data.boxes[6]);\n            flowchart.ops.createLine(flowchart.data.boxes[6], flowchart.data.boxes[1]);\n            flowchart.ops.createLine(flowchart.data.boxes[1], flowchart.data.boxes[5]);\n            flowchart.ops.createLine(flowchart.data.boxes[5], flowchart.data.boxes[2]);\n            flowchart.ops.createLine(flowchart.data.boxes[2], flowchart.data.boxes[4]);\n            flowchart.ops.createLine(flowchart.data.boxes[4], flowchart.data.boxes[3]);\n\n            flowchart.ops.flowchartLineSpacing();\n        },\n\n        /**\n         * Function to automatically space the flowchart lines to prevent run-ins\n         */\n        flowchartLineSpacing: function(){\n            var i, j, k, distance, force, chanTop, chanBot;\n            var maxForce = 0;\n            var fdl = flowchart.data.lines;\n            var fsf = flowchart.settings.forces;\n\n            //number of iterations to attempt to reach equilibrium\n            for(k = 0; k < 50; k++){\n                maxForce = 0;\n\n                for(i = 0; i < fdl.length; i++){\n\n                    //add minor forces for overall direction of arrow to main line if possible\n                    if(fdl[i].startY > fdl[i].mainY){\n                        distance = fdl[i].startY - fdl[i].mainY;\n                        force = Math.max(fsf.c4 * Math.log(fsf.c5 / distance), 0);\n                        fdl[i].mainForce += force;\n                    }else{\n                        distance = fdl[i].mainY - fdl[i].startY;\n                        force = Math.max(fsf.c4 * Math.log(fsf.c5 / distance), 0);\n                        fdl[i].mainForce -= force;\n                    }\n                    if(fdl[i].endY > fdl[i].mainY){\n                        distance = fdl[i].endY - fdl[i].mainY;\n                        force = Math.max(fsf.c4 * Math.log(fsf.c5 / distance), 0);\n                        fdl[i].mainForce += force;\n                    }else{\n                        distance = fdl[i].mainY - fdl[i].endY;\n                        force = Math.max(fsf.c4 * Math.log(fsf.c5 / distance), 0);\n                        fdl[i].mainForce -= force;\n                    }\n\n                    //deal with channel forces by finding the channels for the y direction\n                    chanTop = flowchart.settings.chart.menuTop + flowchart.settings.chart.boxHeight;\n                    chanBot = flowchart.settings.chart.menuTop + flowchart.settings.chart.boxHeight + flowchart.settings.chart.vertSpacing;\n\n                    while(!(fdl[i].mainY >= chanTop - (flowchart.settings.chart.boxHeight / 2) && fdl[i].mainY <= chanBot + (flowchart.settings.chart.boxHeight / 2))){\n                       chanTop += flowchart.settings.chart.boxHeight + flowchart.settings.chart.vertSpacing;\n                       chanBot += flowchart.settings.chart.boxHeight + flowchart.settings.chart.vertSpacing;\n                    }\n\n                    //top of the channel\n                    distance = fdl[i].mainY - chanTop + 1;\n                    //line jumped the channel, needs to move up a channel\n                    if(distance <= 0){\n                        fdl[i].mainY -= flowchart.settings.chart.boxHeight;\n                        flowchart.debug(\"Iteration \" + k + \": jumped line \" + i + \" up a channel to \" + fdl[i].mainY);\n                        fdl[i].mainForce = 0;\n                        continue;\n                    }\n                    force = Math.max(fsf.c6 * Math.log(fsf.c7 / distance), 0);\n                    fdl[i].mainForce += force;\n\n                    //bottom of the channel\n                    distance = chanBot - fdl[i].mainY  + 1;\n                    //line jumped the channel, needs to move down a channel\n                    if(distance <= 0){\n                        fdl[i].mainY += flowchart.settings.chart.boxHeight;\n                        flowchart.debug(\"Iteration \" + k + \": jumped line \" + i + \" down a channel to \" + fdl[i].mainY);\n                        fdl[i].mainForce = 0;\n                        continue;\n                    }\n                    force = Math.max(fsf.c6 * Math.log(fsf.c7 / distance), 0);\n                    fdl[i].mainForce -= force;\n\n                    //TODO: channel forces for starting & ending lines\n\n                    //compare to each additional arrow\n                    for(j = i+1; j < fdl.length; j++){\n\n                        //mainY lines\n                        if(flowchart.utils.linesOverlap(fdl[i].startX, fdl[i].endX, fdl[j].startX, fdl[j].endX)){\n                            force = flowchart.ops.compareLines(fdl[i], fdl[j], \"mainY\", \"mainY\", \"mainForce\", \"mainForce\");\n                            maxForce = force > maxForce ? force : maxForce;\n                        }\n\n                        //startX and startX\n                        if(flowchart.utils.linesOverlap(fdl[i].startY, fdl[i].mainY, fdl[j].startY, fdl[j].mainY)){\n                            force = flowchart.ops.compareLines(fdl[i], fdl[j], \"startX\", \"startX\", \"startForce\", \"startForce\");\n                            maxForce = force > maxForce ? force : maxForce;\n                        }\n\n                        //startX and endX\n                        if(flowchart.utils.linesOverlap(fdl[i].startY, fdl[i].mainY, fdl[j].endY, fdl[j].mainY)){\n                            force = flowchart.ops.compareLines(fdl[i], fdl[j], \"startX\", \"endX\", \"startForce\", \"endForce\");\n                            maxForce = force > maxForce ? force : maxForce;\n                        }\n\n                        //endX and startX\n                        if(flowchart.utils.linesOverlap(fdl[i].endY, fdl[i].mainY, fdl[j].startY, fdl[j].mainY)){\n                            force = flowchart.ops.compareLines(fdl[i], fdl[j], \"endX\", \"startX\", \"endForce\", \"startForce\");\n                            maxForce = force > maxForce ? force : maxForce;\n                        }\n\n                        //endX and endX\n                        if(flowchart.utils.linesOverlap(fdl[i].endY, fdl[i].mainY, fdl[j].endY, fdl[j].mainY)){\n                            force = flowchart.ops.compareLines(fdl[i], fdl[j], \"endX\", \"endX\", \"endForce\", \"endForce\");\n                            maxForce = force > maxForce ? force : maxForce;\n                        }\n\n                    }\n\n                    //update the coordinates based on the force applied\n                    fdl[i].mainY = +fdl[i].mainY + (+fsf.c3 * fdl[i].mainForce);\n                    fdl[i].startX = +fdl[i].startX + (+fsf.c3 * fdl[i].startForce);\n                    fdl[i].endX = +fdl[i].endX + (+fsf.c3 * fdl[i].endForce);\n                    flowchart.ops.setLineAttrs(fdl[i]);\n                    flowchart.debug(\"Iteration \" + k + \": moved line \" + i + \" to \" + fdl[i].startX + \",\" + fdl[i].mainY + \",\" + fdl[i].endX);\n                    fdl[i].mainForce = 0;\n                    fdl[i].startForce = 0;\n                    fdl[i].endForce = 0;\n                }\n\n                //if none of the forces were larger than the threshhold, stop trying and lock them in place\n                if(maxForce < fsf.t){\n                    break;\n                }\n            }\n        },\n\n        /**\n         * Function to compare lines for force directed drawing. This helps minimize \n         * the code in the flowchartLineSpacing function above \n         *\n         * @param line1 {flowchartLine object} - the first line to compare\n         * @param line2 {flowchartLine object} - the second line to compare\n         * @param prop1 {flowchartLine property name as a string} - the property of the first line to use\n         * @param prop2 {flowchartLine property name as a string} - the property of the second line to use\n         * @param force1 {flowchartLine property name as a string} - the property of the first line to update\n         * @param force2 {flowchartLine property name as a string} - the property of the second line to update\n         * @return {float} - the calculated force value\n         */\n        compareLines: function(line1, line2, prop1, prop2, force1, force2){\n            var force, distance;\n            var fsf = flowchart.settings.forces;\n            //check to see if they are close enough to matter\n            if(Math.abs(line1[prop1] - line2[prop2]) <= fsf.c2){\n\n                //if so, figure out which one is greatest\n                if(line1[prop1] > line2[prop2]){\n                    distance = line1[prop1] - line2[prop2] + 0.1;\n                    force = Math.max(fsf.c1 * Math.log(fsf.c2 / distance), 0);\n                    line1[force1] += force;\n                    line2[force2] -= force;\n                }else{\n                    distance = line2[prop2] - line1[prop1] + 0.1;\n                    force = Math.max(fsf.c1 * Math.log(fsf.c2 / distance), 0);\n                    line1[force1] -= force;\n                    line2[force2] += force;\n                }\n                return force\n            }\n\n            return 0;\n        }\n    },\n\n    //utility functions\n    utils: {\n        /**\n         * This function will remove the given CSS class from ALL objects in the flowchart\n         */\n        removeClassFromAll: function(classCSS){\n            //remove the given class from any flowchart elements\n            flowchart.s.selectAll(\".\" + classCSS).forEach(function(element) {\n                element.removeClass(classCSS);\n            });\n        },\n\n        /**\n         * Determine if lines overlap\n         *\n         * @param x1 {float} - the first point of the first line\n         * @param y1 {float} - the second point of the first line\n         * @param x2 {float} - the first point of the second line\n         * @param y2 {float} - the second point of the second line\n         * @return {boolean} - if the lines overlap\n         */\n        linesOverlap: function(x1, y1, x2, y2){\n            var start1, end1, start2, end2;\n            if(x1 < y1){\n                start1 = x1;\n                end1 = y1;\n            }else{\n                start1 = y1;\n                end1 = x1;\n            }\n            if(x2 < y2){\n                start2 = x2;\n                end2 = y2;\n            }else{\n                start2 = y2;\n                end2 = x2;\n            }\n            if(start1 <= start2 && end1 + flowchart.settings.forces.c2 >= start2){\n                return true;\n            }\n            if(start2 <= start1 && end2 + flowchart.settings.forces.c2 >= start1){\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Highlights drop zones as we hover over them\n         * \n         * @param {int} x - the x position of our hover object\n         * @param {int} y - the y position of our hover object\n         */\n        highlightDrop: function(x, y){\n            //Alias for the flowchart settings & runtime for code readability\n            var fsc = flowchart.settings.chart;\n            var fr = flowchart.runtime;\n\n            //calculate the row and column of the drop zone\n            var row = Math.floor(((x / fr.scale) - fsc.toolboxLeft) / (fsc.boxWidth + fsc.horizSpacing));\n            var col = Math.floor(((y / fr.scale) - fsc.menuTop) / (fsc.boxHeight + fsc.vertSpacing));\n\n            //check to see if we need to change, if not, don't update DOM (for speed)\n            if(row != fr.dropZoneX || col != fr.dropZoneY){\n                //remove hover class from previous drop zone if it is valid\n                flowchart.utils.highlightDropClear();\n\n                //make sure drop zone is valid\n                if(row >= 0 && row < flowchart.config.gridRows && col >= 0 && col < flowchart.config.gridCols){\n                    //update to new drop zone\n                    fr.dropZoneX = row;\n                    fr.dropZoneY = col;\n\n                    //add hover class to new drop zone\n                    flowchart.data.drops[fr.dropZoneX][fr.dropZoneY].addClass(\"hover\");\n                }else{\n                    //clear drop done to invalid values\n                    fr.dropZoneX = -1;\n                    fr.dropZoneY = -1;\n                }\n            }\n        },\n\n        /**\n         * Clears the currently highlighted drop zone\n         */\n        highlightDropClear: function(){\n            //Alias for the flowchart runtime for code readability\n            var fr = flowchart.runtime;\n            if(fr.dropZoneX >= 0 && fr.dropZoneY >= 0){\n                flowchart.data.drops[fr.dropZoneX][fr.dropZoneY].removeClass(\"hover\");\n            }\n\n            //clear variables\n            fr.dropZoneX = -1;\n            fr.dropZoneY = -1;\n        },\n\n        /**\n         * Gets the real x & y pixel coordinates of the current drop zone\n         * \n         * @param {flowchartBox Object} element - the element to be animated\n         */\n        animateToDropZone: function(element){\n            //Alias for the flowchart settings & runtime for code readability\n            var fsc = flowchart.settings.chart;\n            var fr = flowchart.runtime;\n\n            //check to see if new drop zone coordinates are valid\n            if(fr.dropZoneX >= 0 && fr.dropZoneY >= 0){\n\n                //Calcuate x and y coordinates of the drop zone\n                var x = fsc.toolboxLeft + fsc.dropBoxOffset + (fr.dropZoneX * (fsc.boxWidth + fsc.vertSpacing));\n                var y = fsc.menuTop + fsc.dropBoxOffset + (fr.dropZoneY * (fsc.boxHeight + fsc.horizSpacing));\n\n                //animate the element to those coordinates\n                element.svgElem.animate({x: x, y: y}, fsc.animationSpeed, mina.linear, function(){\n                    flowchart.utils.updateLines(element);\n                });\n\n                //update the position of the current element\n                element.flowX = flowchart.runtime.dropZoneX;\n                element.flowY = flowchart.runtime.dropZoneY;\n            }else{\n                //Calcuate x and y coordinates of the drop zone\n                var x = fsc.toolboxLeft + fsc.dropBoxOffset + (element.flowX * (fsc.boxWidth + fsc.vertSpacing));\n                var y = fsc.menuTop + fsc.dropBoxOffset + (element.flowY * (fsc.boxHeight + fsc.horizSpacing));\n\n                //animate the element to those coordinates\n                element.svgElem.animate({x: x, y: y}, fsc.animationSpeed, mina.linear, function(){\n                    flowchart.utils.updateLines(element);\n                });\n            }\n        },\n\n        /**\n         * Helper function to update lines attached to a box after it has been animated into place\n         *\n         * @param box {flowchatBox object} - the box attached to the lines to be animated\n         */\n        updateLines: function(box){\n            flowchart.debug(\"Updating lines after move\");\n            \n            //update any lines attached to the box\n            flowchart.data.lines.forEach(function(element){\n                flowchart.ops.updateLine(element);\n            });\n\n            //use force directed spacing to arrange the lines\n            flowchart.ops.flowchartLineSpacing();\n        },\n\n         /**\n          * This function updates the scale variable as the flowchart SVG element is resized\n          */\n        updateScale: function(){\n            //get the value of the SVG element's viewbox\n            var viewBox = document.getElementById(\"svg\").getAttribute(\"viewBox\").split(\" \");\n\n            var height = document.getElementById(\"svg\").parentNode.clientHeight;\n            var width = document.getElementById(\"svg\").parentNode.clientHeight;\n            \n            flowchart.runtime.scale = Math.max((width / viewBox[2]), (height / viewBox[3]));\n            flowchart.debug(\"scale updated to \" + flowchart.runtime.scale + \" based on dimensions \" + width + \"x\" + height);\n        },\n\n        /**\n         * This function updates the SVG viewbox to match the bounding box of the SVG itself\n         */\n        updateViewBox: function(){\n            flowchart.runtime.boundingBox = flowchart.s.getBBox();\n            document.getElementById(\"svg\").setAttribute(\"viewBox\", \"0 0 \" + flowchart.runtime.boundingBox.width + \" \"  + flowchart.runtime.boundingBox.height);\n        },\n\n        /**\n         * This function attaches an event handler safely (based on how JQuery does it)\n         * @see http://stackoverflow.com/questions/641857/javascript-window-resize-event\n         * \n         * @param {DOM Element} elem - the element to attach to\n         * @param {string} type - the type of event to attach to\n         * @param {function} eventHandle - the event handler function to be called\n         */\n        addEvent: function(elem, type, eventHandle) {\n            if (elem === null || typeof(elem) == 'undefined'){\n                return;\n            }\n            if ( elem.addEventListener ) {\n                elem.addEventListener( type, eventHandle, false );\n            } else if ( elem.attachEvent ) {\n                elem.attachEvent( \"on\" + type, eventHandle );\n            } else {\n                elem[\"on\"+type]=eventHandle;\n            }\n        },\n\n        /**\n         * This function bounds a value by a minimum and maximum value\n         */\n        bound: function(value, min, max){\n            if(value < min) return min;\n            if(value > max) return max;\n            return value;\n        }\n    }\n};\n\nwindow.onload = function() {\n    flowchart.init(\"svgcont\", {\n        drawToolbox: true\n    });\n};"],"sourceRoot":"/source/"}